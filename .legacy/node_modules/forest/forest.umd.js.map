{"version":3,"file":"forest.umd.js","sources":["../../src/forest/plan/index.ts","../../src/forest/bindings.ts","../../src/forest/template.ts","../../src/forest/search.ts","../../src/forest/assert.ts","../../src/forest/mountChild.ts","../../src/forest/mutualSample.ts","../../src/forest/forIn.ts","../../src/forest/method/handler.ts","../../src/forest/method/spec.ts","../../src/forest/method/h.ts","../../src/forest/method/using.ts","../../src/forest/iterateChildLeafs.ts","../../src/forest/unmount.ts","../../src/forest/method/remap.ts","../../src/forest/method/list.ts","../../src/forest/method/route.ts","../../src/forest/method/rec.ts","../../src/forest/wordsArray.ts","../../src/forest/platform/env.ts","../../src/forest/platform/now.ts","../../src/forest/platform/mark.ts","../../src/forest/platform/raf.ts","../../src/forest/templateHandlers.ts","../../src/forest/mountFn.ts","../../src/forest/method/block.ts","../../src/forest/method/node.ts","../../src/forest/method/text.ts","../../src/forest/method/tree.ts","../../src/forest/method/val.ts","../../src/forest/method/variant.ts"],"sourcesContent":["import {TASK_DEADLINE} from '../platform/env'\nimport {now} from '../platform/now'\nimport {beginMark, endMark} from '../platform/mark'\nimport {raf} from '../platform/raf'\nimport type {\n  Op,\n  OpPriorityQueue,\n  OpGroup,\n  AsyncValue,\n  Linkable,\n} from './index.h'\n\nfunction addItemToQueue(\n  queue: {first: Linkable | null; last: Linkable | null},\n  item: Linkable,\n) {\n  if (queue.last) {\n    item.cursor.prev = queue.last\n    queue.last.cursor.next = item\n    queue.last = item\n  } else {\n    queue.first = queue.last = item\n  }\n}\n\nfunction removeItemFromQueue(\n  queue: {first: Linkable | null; last: Linkable | null},\n  item: Linkable,\n) {\n  if (item.cursor.prev) {\n    item.cursor.prev.cursor.next = item.cursor.next\n  }\n  if (item.cursor.next) {\n    item.cursor.next.cursor.prev = item.cursor.prev\n  }\n  if (queue.last === item) {\n    queue.last = item.cursor.prev\n  }\n  if (queue.first === item) {\n    queue.first = item.cursor.next\n  }\n  item.cursor.prev = null\n  item.cursor.next = null\n}\n\n//prettier-ignore\nfunction removeOpGroupFromQueue(\n  group: OpGroup,\n  priority: 'props' | 'tree' | 'data'\n) {\n  if (group.cursor[priority].prev) {\n    group.cursor[priority].prev!.cursor[priority].next = group.cursor[priority].next\n  }\n  if (group.cursor[priority].next) {\n    group.cursor[priority].next!.cursor[priority].prev = group.cursor[priority].prev\n  }\n  if (group.queue[priority].last === group) {\n    group.queue[priority].last = group.cursor[priority].prev\n  }\n  if (group.queue[priority].first === group) {\n    group.queue[priority].first = group.cursor[priority].next\n  }\n  group.cursor[priority].prev = null\n  group.cursor[priority].next = null\n}\n\nfunction removeOpFromQueue(op: Op) {\n  op.status = 'active'\n  removeItemFromQueue(getOpQueue(op), op)\n}\n\nfunction addOpGroupToQueue(\n  group: OpGroup,\n  priority: 'props' | 'tree' | 'data',\n) {\n  if (group.queue[priority].last) {\n    group.cursor[priority].prev = group.queue[priority].last\n    group.queue[priority].last!.cursor[priority].next = group\n    group.queue[priority].last = group\n  } else {\n    group.queue[priority].first = group.queue[priority].last = group\n  }\n}\n\nfunction getOpQueue(op: Op) {\n  return op.group.activeChilds[op.priority]\n}\n\nexport function forceSetOpValue(value: any, op: Op) {\n  op.value.active = op.value.pending = value\n  if (op.status === 'active') return\n  removeOpFromQueue(op)\n}\n\nexport function pushOpToQueue(value: any, op: Op) {\n  if (op.value.active === value) {\n    op.value.pending = value\n    if (op.status === 'pending') {\n      removeOpFromQueue(op)\n      if (!getOpQueue(op).first) {\n        removeOpGroupFromQueue(op.group, op.priority)\n      }\n    }\n    return\n  }\n  if (op.status === 'active') {\n    op.status = 'pending'\n    if (!getOpQueue(op).first) {\n      addOpGroupToQueue(op.group, op.priority)\n    }\n    addItemToQueue(getOpQueue(op), op)\n  }\n  op.value.pending = value\n  if (!op.group.queue.rafID) {\n    op.group.queue.rafID = raf(op.group.queue.execQueue)\n  }\n}\n\nfunction execQueue(queue: OpPriorityQueue) {\n  beginMark('execQueue')\n  const start = now()\n  let interrupted = false\n  let group: OpGroup | null\n  let op: Op | null\n\n  quant: {\n    while (queue.props.first || queue.tree.first || queue.data.first) {\n      if (now() - start >= TASK_DEADLINE) {\n        interrupted = true\n        break quant\n      }\n      const hasPropsTasks = !!queue.props.first\n      if (hasPropsTasks) beginMark('props')\n\n      while ((group = queue.props.first)) {\n        while ((op = group.activeChilds.props.first)) {\n          if (now() - start >= TASK_DEADLINE) {\n            interrupted = true\n            endMark('props')\n            break quant\n          }\n          op.runOp(op.value.pending)\n          op.value.active = op.value.pending\n          removeOpFromQueue(op)\n        }\n        removeOpGroupFromQueue(group, 'props')\n      }\n      if (hasPropsTasks) endMark('props')\n\n      const hasTreeTasks = !!queue.tree.first\n      if (hasTreeTasks) beginMark('tree')\n\n      while ((group = queue.tree.first)) {\n        while ((op = group.activeChilds.tree.first)) {\n          if (now() - start >= TASK_DEADLINE) {\n            interrupted = true\n            endMark('tree')\n            break quant\n          }\n          op.runOp(op.value.pending)\n          op.value.active = op.value.pending\n          removeOpFromQueue(op)\n        }\n        removeOpGroupFromQueue(group, 'tree')\n      }\n      if (hasTreeTasks) endMark('tree')\n\n      const hasDataTasks = !!queue.data.first\n      if (hasDataTasks) beginMark('data')\n\n      while ((group = queue.data.first)) {\n        while ((op = group.activeChilds.data.first)) {\n          if (now() - start >= TASK_DEADLINE) {\n            interrupted = true\n            endMark('data')\n            break quant\n          }\n          op.runOp(op.value.pending)\n          op.value.active = op.value.pending\n          removeOpFromQueue(op)\n        }\n        removeOpGroupFromQueue(group, 'data')\n      }\n      if (hasDataTasks) endMark('data')\n    }\n  }\n  endMark('execQueue')\n  if (interrupted) {\n    queue.rafID = raf(queue.execQueue)\n  } else {\n    queue.rafID = null\n    if (queue.onDrain) {\n      const rs = queue.onDrain\n      queue.onDrain = null\n      rs()\n    }\n  }\n}\n\nexport function createOp({\n  value,\n  runOp,\n  group,\n  priority,\n}: {\n  value: any\n  runOp: (value: any) => void\n  group: OpGroup\n  priority: 'props' | 'tree' | 'data'\n}): Op {\n  return {\n    value: {\n      active: value,\n      pending: value,\n    },\n    runOp,\n    status: 'active',\n    priority,\n    group,\n    cursor: {\n      prev: null,\n      next: null,\n    },\n  }\n}\n\nexport function createOpQueue({\n  onComplete,\n}: {\n  onComplete?: () => void\n}): OpPriorityQueue {\n  const queue: OpPriorityQueue = {\n    props: {\n      first: null,\n      last: null,\n    },\n    tree: {\n      first: null,\n      last: null,\n    },\n    data: {\n      first: null,\n      last: null,\n    },\n    rafID: null,\n    execQueue() {},\n    onDrain: onComplete,\n  }\n  queue.execQueue = execQueue.bind(null, queue)\n  return queue\n}\n\nexport function createOpGroup(queue: OpPriorityQueue): OpGroup {\n  return {\n    ops: [],\n    queue,\n    activeChilds: {\n      props: {\n        first: null,\n        last: null,\n      },\n      tree: {\n        first: null,\n        last: null,\n      },\n      data: {\n        first: null,\n        last: null,\n      },\n    },\n    cursor: {\n      props: {\n        prev: null,\n        next: null,\n      },\n      tree: {\n        prev: null,\n        next: null,\n      },\n      data: {\n        prev: null,\n        next: null,\n      },\n    },\n  }\n}\n\nexport function createAsyncValue({\n  value,\n  group,\n  onInit,\n  onChange,\n}: {\n  value: any\n  group: OpGroup\n  onInit: (value: any) => void\n  onChange: (value: any) => void\n}): AsyncValue {\n  const change = createOp({\n    value,\n    group,\n    runOp(value) {\n      item.status = 'A'\n      onChange(value)\n    },\n    priority: 'data',\n  })\n  const item: AsyncValue = {\n    status: 'IA',\n    value: change.value,\n    ops: {\n      init: createOp({\n        value: false,\n        group,\n        runOp(value) {\n          item.status = 'A'\n          onInit(item.value.active)\n        },\n        priority: 'data',\n      }),\n      change,\n      terminate: createOp({\n        value: false,\n        group,\n        runOp(value) {\n          item.status = 'T'\n        },\n        priority: 'data',\n      }),\n    },\n  }\n  pushOpToQueue(true, item.ops.init)\n  return item\n}\n\nexport function stopAsyncValue(item: AsyncValue) {\n  switch (item.status) {\n    case 'I':\n    case 'T':\n    case 'AT':\n      return\n    case 'A':\n      item.status = 'AT'\n      pushOpToQueue(true, item.ops.terminate)\n      break\n    case 'AA':\n      item.status = 'AT'\n      pushOpToQueue(true, item.ops.terminate)\n      pushOpToQueue(item.value.active, item.ops.change)\n      break\n    case 'IA':\n      item.status = 'T'\n      pushOpToQueue(false, item.ops.init)\n      break\n  }\n}\n\nexport function updateAsyncValue(value: any, item: AsyncValue) {\n  switch (item.status) {\n    case 'I':\n    case 'T':\n      return\n    case 'A':\n      if (item.value.active !== value) {\n        item.status = 'AA'\n        pushOpToQueue(value, item.ops.change)\n      }\n      break\n    case 'AA':\n      if (item.value.active === value) {\n        item.status = 'A'\n        pushOpToQueue(value, item.ops.change)\n      } else if (item.value.pending !== value) {\n        item.value.pending = value\n      }\n      break\n    case 'IA':\n      item.value.active = item.value.pending = value\n      break\n    case 'AT':\n      // item.status = item.value.active === value ? 'A' : 'AA'\n      // pushOpToQueue(value, item.ops.change)\n      // pushOpToQueue(false, item.ops.terminate)\n      break\n  }\n}\n","import type {DOMElement, StaticOperationDef} from './index.h'\n\nconst defMap = {\n  attr: applyAttr,\n  data: applyDataAttr,\n  style: applyStyle,\n  styleVar: applyStyleVar,\n}\n\nexport function escapeTag(value: string) {\n  value = String(value)\n  switch (value) {\n    case '__proto__':\n    case '__defineGetter__':\n    case '__defineSetter__':\n    case 'constructor':\n    case 'prototype':\n    case 'hasOwnProperty':\n    case 'toString':\n    case 'valueOf':\n    case 'setProperty':\n    case 'removeProperty':\n      return 'forbidden'\n    default:\n      return value.replace(/[^a-zA-Z0-9\\-_]/g, '')\n  }\n}\n\nexport function applyStaticOps(\n  element: DOMElement,\n  defs: StaticOperationDef[],\n) {\n  for (let i = 0; i < defs.length; i++) {\n    const {type, field, value} = defs[i]\n    defMap[type](element, field, value)\n  }\n}\n\nexport function isFalse(val: any) {\n  return (\n    val !== '' &&\n    val !== 0 &&\n    val !== '0' &&\n    (val === false || val === undefined || val === null)\n  )\n}\n\nexport function applyStyleVar(\n  element: DOMElement,\n  field: string,\n  value: string | number | boolean | null,\n) {\n  if (isFalse(value)) {\n    element.style.removeProperty(`--${field}`)\n  } else {\n    element.style.setProperty(`--${field}`, `${value}`)\n  }\n}\n\nexport function applyStyle(\n  element: DOMElement,\n  field: string,\n  value: string | number | boolean | null,\n) {\n  if (isFalse(value)) {\n    delete element.style[field as any]\n  } else {\n    element.style[field as any] = `${value}`\n  }\n}\n\nexport function applyDataAttr(\n  element: DOMElement,\n  field: string,\n  value: string | number | boolean | null,\n) {\n  if (isFalse(value)) {\n    delete element.dataset[field]\n  } else {\n    element.dataset[field] = `${value}`\n  }\n}\nexport function applyAttr(\n  element: DOMElement,\n  field: string,\n  value: string | number | boolean | null,\n) {\n  if (isFalse(value)) {\n    switch (field) {\n      case 'value':\n        //@ts-expect-error\n        delete element.value\n        break\n      case 'checked':\n        //@ts-expect-error\n        element.checked = false\n        break\n      case 'spellcheck':\n        if (value === false) {\n          element.setAttribute('spellcheck', 'false')\n          return\n        }\n        break\n    }\n    element.removeAttribute(field)\n  } else {\n    switch (field) {\n      case 'value':\n        //@ts-expect-error\n        element.value = `${value}`\n        break\n      case 'checked':\n        //@ts-expect-error\n        element.checked = `${value}`\n        break\n    }\n    element.setAttribute(field, `${value}`)\n  }\n}\n\nexport function applyText(textNode: Text, text: string | number | boolean) {\n  textNode.replaceData(0, (textNode.textContent || '').length, String(text))\n}\n","import {\n  Store,\n  Event,\n  launch,\n  step,\n  createNode,\n  withRegion,\n  restore,\n  createEvent,\n} from 'effector'\nimport type {Scope} from '../effector/unit.h'\nimport type {StateRef} from '../effector/index.h'\nimport type {Stack} from '../effector/kernel'\nimport type {\n  Leaf,\n  NSType,\n  DOMElement,\n  LeafData,\n  Template,\n  NodeDraft,\n  Root,\n} from './index.h'\nimport type {OpGroup} from './plan/index.h'\nimport {handlers} from './templateHandlers'\n\nlet templateID = 0\nlet spawnID = 0\nexport let currentTemplate: Template | null = null\nexport let currentLeaf: Leaf | null = null\n\nexport function createTemplate<Api extends {[method: string]: any}>(config: {\n  fn: (\n    state: {\n      [field: string]: Store<any>\n    },\n    triggers: {\n      mount: Event<Leaf>\n    },\n  ) => {[K in keyof Api]: Event<Api[K]>}\n  state?: {[field: string]: any}\n  defer?: boolean\n  name: string\n  isSvgRoot: boolean\n  draft: NodeDraft\n  namespace: NSType\n  env: {\n    document: Document\n  }\n  isBlock?: boolean\n}): Template\n//@ts-expect-error\nexport function createTemplate(config: {\n  fn: (\n    state: {\n      [field: string]: Store<any>\n    },\n    triggers: {\n      mount: Event<Leaf>\n    },\n  ) => void\n  state?: {[field: string]: any}\n  defer?: boolean\n  name: string\n  isSvgRoot: boolean\n  draft: NodeDraft\n  namespace: NSType\n  env: {\n    document: Document\n  }\n  isBlock?: boolean\n}): Template\nexport function createTemplate<Api extends {[method: string]: any}>({\n  fn,\n  state: values = {},\n  defer = false,\n  name = '',\n  draft,\n  isSvgRoot,\n  namespace,\n  env,\n  isBlock = false,\n}: {\n  fn: (\n    state: {\n      [field: string]: Store<any>\n    },\n    triggers: {\n      mount: Event<Leaf>\n    },\n  ) => {[K in keyof Api]: Event<Api[K]>}\n  state?: {[field: string]: any}\n  defer?: boolean\n  name: string\n  isSvgRoot: boolean\n  draft: NodeDraft\n  namespace: NSType\n  env: {\n    document: Document\n  }\n  isBlock?: boolean\n}): Template {\n  const parent = currentTemplate\n  const template: Template = {\n    id: ++templateID,\n    name,\n    plain: [],\n    watch: [],\n    nameMap: {},\n    pages: [],\n    closure: [],\n    childTemplates: [],\n    handlers,\n    upward: step.filter({\n      //@ts-expect-error\n      fn(upd, scope, stack: Stack) {\n        if (!stack.page) {\n          if (stack.parent && stack.parent.page) {\n            stack.page = stack.parent.page\n          } else {\n            // console.error('context lost', stack)\n            return true\n          }\n        }\n        if (!stack.page.root.activeSpawns.has(stack.page.fullID)) {\n          console.count('inactive page upward')\n          return false\n        }\n        const stackTemplates = [stack.page.template]\n        const stackPages = [stack.page]\n        {\n          let currentStackPage = stack.page.parent\n          while (currentStackPage) {\n            stackPages.push(currentStackPage)\n            stackTemplates.push(currentStackPage.template)\n            currentStackPage = currentStackPage.parent\n          }\n        }\n        stack.node.next.forEach(node => {\n          /**\n           * node.meta.nativeTemplate is used in units\n           * it represents template in which unit was created (belongs to)\n           */\n          const targetTemplate: Template | void = node.meta.nativeTemplate\n          if (targetTemplate) {\n            if (stackTemplates.includes(targetTemplate)) {\n              const page = stackPages[stackTemplates.indexOf(targetTemplate)]\n              launch({\n                //@ts-expect-error\n                target: node,\n                params: upd,\n                defer: true,\n                page,\n                stack,\n                //@ts-expect-error\n                scope: stack.scope,\n              })\n            } else {\n              console.error('context drift', {stack, node})\n            }\n          } else {\n            launch({\n              //@ts-expect-error\n              target: node,\n              params: upd,\n              defer: true,\n              page: stack.page,\n              stack,\n              //@ts-expect-error\n              scope: stack.scope,\n            })\n          }\n        })\n        return false\n      },\n    }),\n    loader: step.filter({\n      //@ts-expect-error\n      fn(upd, scope, stack: Stack) {\n        if (stack.parent) {\n          const forkId = stack.scope ? stack.scope.graphite.id : null\n          if (stack.page) {\n            if (!stack.page.root.activeSpawns.has(stack.page.fullID)) {\n              console.count('inactive page loader')\n              return false\n            }\n            if (stack.page.template === template) {\n              return true\n            }\n\n            if (stack.page.root.childSpawns[stack.page.fullID][template.id]) {\n              const fullID = stack.page!.fullID\n              stack.page.root.childSpawns[fullID][template.id].forEach(page => {\n                if (forkId) {\n                  if (\n                    !page.root.scope ||\n                    forkId !== page.root.scope.graphite.id\n                  )\n                    return\n                }\n                launch({\n                  params: upd,\n                  //@ts-expect-error\n                  target: stack.node,\n                  page,\n                  defer: true,\n                  //@ts-expect-error\n                  scope: stack.scope,\n                })\n              })\n            } else {\n              const fullID = stack.page.fullID\n              const isRecTemplate = stack.page.template.name === 'rec'\n\n              template.pages.forEach(page => {\n                if (forkId) {\n                  if (\n                    !page.root.scope ||\n                    forkId !== page.root.scope.graphite.id\n                  )\n                    return\n                }\n                if (\n                  page.fullID === fullID ||\n                  page.fullID.startsWith(`${fullID}_`)\n                ) {\n                  let validTarget = true\n                  if (isRecTemplate) {\n                    const recID = stack.page!.template.id\n                    let parentPage = page.parent\n                    while (parentPage) {\n                      if (parentPage === stack.page) {\n                        break\n                      }\n                      if (parentPage.template.id === recID) {\n                        validTarget = false\n                        break\n                      }\n                      parentPage = parentPage.parent\n                    }\n                  }\n                  if (validTarget) {\n                    launch({\n                      params: upd,\n                      //@ts-expect-error\n                      target: stack.node,\n                      page,\n                      defer: true,\n                      //@ts-expect-error\n                      scope: stack.scope,\n                    })\n                  }\n                } else {\n                  if (fullID.startsWith(`${page.fullID}_`)) {\n                    launch({\n                      params: upd,\n                      //@ts-expect-error\n                      target: stack.node,\n                      page: stack.page,\n                      defer: true,\n                      //@ts-expect-error\n                      scope: stack.scope,\n                    })\n                  } else {\n                    // console.count('no page match')\n                  }\n                }\n              })\n            }\n          } else {\n            template.pages.forEach(page => {\n              if (forkId) {\n                if (!page.root.scope || forkId !== page.root.scope.graphite.id)\n                  return\n              }\n              launch({\n                params: upd,\n                //@ts-expect-error\n                target: stack.node,\n                page,\n                defer: true,\n                //@ts-expect-error\n                scope: stack.scope,\n              })\n            })\n          }\n          return false\n        }\n        return true\n      },\n    }),\n    parent,\n    node: null as any,\n    api: null as any,\n    trigger: {\n      //@ts-expect-error\n      mount: createEvent<Leaf>({named: 'mount'}),\n    },\n    draft,\n    isSvgRoot,\n    namespace,\n    env,\n    isBlock: isBlock || !!(parent && parent.isBlock),\n  }\n  if (parent) {\n    parent.childTemplates.push(template)\n  }\n  const node = createNode({\n    meta: {\n      template,\n    },\n  })\n  template.node = node\n  currentTemplate = template\n  if (!defer) {\n    withRegion(node, () => {\n      const state = restore(values)\n      template.api = fn(state, template.trigger)\n      template.nameMap = state\n    })\n  } else {\n    template.deferredInit = () => {\n      const prevTemplate = currentTemplate\n      currentTemplate = template\n      template.deferredInit = null\n      try {\n        withRegion(node, () => {\n          const state = restore(values)\n          template.api = fn(state, template.trigger)\n          template.nameMap = state\n        })\n      } finally {\n        currentTemplate = prevTemplate\n      }\n    }\n  }\n  currentTemplate = parent\n  return template\n}\n\nfunction getCurrent(ref: StateRef, forkPage?: Scope) {\n  let result\n  if (forkPage) result = forkPage.getState(ref)\n  else result = ref.current\n  switch (ref.type) {\n    case 'list':\n      return [...result]\n    case 'shape':\n      return {...result}\n    default:\n      return result\n  }\n}\nfunction findRef(\n  ref: StateRef,\n  targetLeaf: Leaf | null,\n  forkPage?: Scope,\n): StateRef {\n  let currentLeaf = targetLeaf\n  while (currentLeaf && !regRef(currentLeaf, ref)) {\n    currentLeaf = currentLeaf.parent\n  }\n  if (!currentLeaf) {\n    if (forkPage) {\n      forkPage.getState(ref)\n      return forkPage.reg[ref.id]\n    }\n    return ref\n  }\n  return regRef(currentLeaf, ref)\n}\nfunction findRefValue(\n  ref: StateRef,\n  targetLeaf: Leaf | null,\n  forkPage?: Scope,\n) {\n  return findRef(ref, targetLeaf, forkPage).current\n}\nfunction ensureLeafHasRef(ref: StateRef, leaf: Leaf) {\n  if (!regRef(leaf, ref)) {\n    leaf.reg[ref.id] = findRef(ref, leaf.parent, leaf.root.scope)\n  }\n}\nconst regRef = (page: {reg: Record<string, StateRef>}, ref: StateRef) =>\n  page.reg[ref.id]\nfunction addMapItems<T>(\n  values: T[],\n  id: string | number,\n  record: Record<string | number, T[]>,\n) {\n  if (!(id in record)) {\n    record[id] = []\n  }\n  record[id].push(...values)\n}\nexport function spawn(\n  template: Template,\n  {\n    values = {},\n    parentLeaf,\n    mountNode,\n    svgRoot,\n    leafData,\n    opGroup,\n    domSubtree,\n    hydration,\n    root,\n  }: {\n    values?: {[field: string]: any}\n    parentLeaf: Leaf | null\n    mountNode: DOMElement\n    svgRoot: SVGSVGElement | null\n    leafData: LeafData\n    opGroup: OpGroup\n    domSubtree: OpGroup\n    hydration: boolean\n    root: Root\n  },\n): Leaf {\n  const page = {} as Record<string, StateRef>\n\n  const leaf: Leaf = {\n    draft: template.draft,\n    svgRoot,\n    data: leafData,\n    parent: parentLeaf,\n    hydration,\n    mountNode,\n    root,\n    id: ++spawnID,\n    fullID: '',\n    reg: page,\n    template,\n  }\n  template.pages.push(leaf)\n  const previousSpawn = currentLeaf\n  currentLeaf = leaf\n  if (parentLeaf) {\n    addMapItems([leaf], template.id, root.childSpawns[parentLeaf.fullID])\n  }\n  if (parentLeaf) {\n    leaf.fullID = `${parentLeaf.fullID}_${leaf.id}`\n  } else {\n    leaf.fullID = `${leaf.id}`\n  }\n  root.childSpawns[leaf.fullID] = {}\n  root.activeSpawns.add(leaf.fullID)\n  root.leafOps[leaf.fullID] = {group: opGroup, domSubtree}\n  for (let i = 0; i < template.closure.length; i++) {\n    const ref = template.closure[i]\n    let closureRef = ref\n    let parent = leaf.parent\n    findClosure: while (parent) {\n      if (regRef(parent, ref)) {\n        closureRef = regRef(parent, ref)\n        break findClosure\n      }\n      parent = parent.parent\n    }\n    if (!parent && root.scope) {\n      root.scope.getState(ref)\n      closureRef = root.scope.reg[ref.id]\n    }\n    page[ref.id] = closureRef\n  }\n\n  for (let i = 0; i < template.plain.length; i++) {\n    const ref = template.plain[i]\n    const next: StateRef = {\n      id: ref.id,\n      current: getCurrent(ref, root.scope),\n    }\n    page[ref.id] = next\n  }\n  for (const name in values) {\n    const id = template.nameMap[name].stateRef.id\n    page[id] = {\n      id,\n      current: values[name],\n    }\n  }\n  function execRef(ref: StateRef) {\n    if (ref.before) {\n      for (let i = 0; i < ref.before.length; i++) {\n        const cmd = ref.before[i]\n        switch (cmd.type) {\n          case 'map': {\n            const from = cmd.from\n            if (!cmd.fn && !from) break\n            let value\n            if (from) {\n              ensureLeafHasRef(from, leaf)\n              value = page[from.id].current\n            }\n            page[ref.id].current = cmd.fn ? cmd.fn(value) : value\n            break\n          }\n          case 'field': {\n            const from = cmd.from\n            ensureLeafHasRef(from, leaf)\n            page[ref.id].current[cmd.field] = page[from.id].current\n            break\n          }\n          case 'closure':\n            ensureLeafHasRef(cmd.of, leaf)\n            break\n        }\n      }\n    }\n  }\n  template.closure.forEach(execRef)\n  template.plain.forEach(execRef)\n\n  function runWatchersFrom(\n    list: any[],\n    state: {i: number; stop: boolean},\n    page: Record<string, StateRef>,\n  ) {\n    state.stop = true\n    let val\n    try {\n      while (state.i < list.length) {\n        val = list[state.i]\n        state.i++\n        val.fn(\n          page[val.of.id]\n            ? page[val.of.id].current\n            : findRefValue(val.of, leaf.parent, leaf.root.scope),\n        )\n      }\n    } catch (err) {\n      console.error(err)\n      state.stop = false\n    }\n  }\n  const state = {i: 0, stop: false}\n  while (!state.stop) {\n    runWatchersFrom(template.watch, state, page)\n  }\n  if (parentLeaf) {\n    for (const id in root.childSpawns[leaf.fullID]) {\n      addMapItems(\n        root.childSpawns[leaf.fullID][id],\n        id,\n        root.childSpawns[parentLeaf.fullID],\n      )\n    }\n  }\n  if (mountQueue) {\n    mountQueue.steps.push({\n      target: template.trigger.mount,\n      params: leaf,\n      defer: true,\n      page: leaf,\n      scope: root.scope,\n    })\n  } else {\n    mountQueue = {\n      parent: mountQueue,\n      steps: [\n        {\n          target: template.trigger.mount,\n          params: leaf,\n          defer: true,\n          page: leaf,\n          scope: root.scope,\n        },\n      ],\n    }\n    let step: any\n    do {\n      while ((step = mountQueue.steps.shift())) {\n        mountQueue = {\n          parent: mountQueue,\n          steps: [],\n        }\n        launch(step)\n      }\n    } while ((mountQueue = mountQueue.parent))\n  }\n  currentLeaf = previousSpawn\n  return leaf\n}\n\ntype MountQueue = {\n  parent: MountQueue | null\n  steps: any[]\n}\n\nlet mountQueue: MountQueue | null = null\n","import type {DOMElement} from './index.h'\n\nimport type {\n  ElementBlock,\n  TextBlock,\n  UsingBlock,\n  Block,\n  BlockBlock,\n} from './relation.h'\n\nexport function findParentDOMElement(\n  block: Exclude<Block, UsingBlock | BlockBlock>,\n): DOMElement | null {\n  let parent = block.parent\n  while (parent.type !== 'element' && parent.type !== 'using') {\n    parent = parent.parent\n  }\n  if (parent) return parent.value\n  return null\n}\nfunction findLastVisibleChildBlock(\n  block: Exclude<Block, UsingBlock>,\n): ElementBlock | TextBlock | null {\n  if (!block.visible) return null\n  switch (block.type) {\n    case 'text':\n    case 'element':\n      return block\n    case 'LF':\n    case 'route':\n    case 'rec':\n    case 'recItem':\n    case 'block':\n    case 'blockItem': {\n      for (let i = block.child.length - 1; i >= 0; i--) {\n        const child = block.child[i]\n        const visibleChild = findLastVisibleChildBlock(child)\n        if (visibleChild) return visibleChild\n      }\n      return null\n    }\n    case 'list': {\n      let child = block.lastChild\n      if (!child) return null\n      while (child) {\n        const visibleChild = findLastVisibleChildBlock(child)\n        if (visibleChild) return visibleChild\n        child = child.left\n      }\n      return null\n    }\n    default: {\n      const _: never = block\n      return null\n    }\n  }\n}\n\nexport function findPreviousVisibleSiblingBlock(\n  block: Block,\n): TextBlock | ElementBlock | null {\n  switch (block.type) {\n    case 'using':\n      return null\n    case 'LF': {\n      let sibling = block.left\n      while (sibling) {\n        const visibleChild = findLastVisibleChildBlock(sibling)\n        if (visibleChild) return visibleChild\n        sibling = sibling.left\n      }\n      return findPreviousVisibleSiblingBlock(block.parent)\n    }\n    case 'element':\n    case 'text':\n    case 'route':\n    case 'rec':\n    case 'recItem':\n    case 'block':\n    case 'blockItem':\n    case 'list': {\n      const parentFragment = block.parent\n      for (let i = block.index - 1; i >= 0; i--) {\n        const sibling = parentFragment.child[i]\n        if (!sibling) continue\n        const visibleChild = findLastVisibleChildBlock(sibling)\n        if (visibleChild) return visibleChild\n      }\n      switch (parentFragment.type) {\n        case 'element':\n        case 'using':\n          return null\n      }\n      return findPreviousVisibleSiblingBlock(parentFragment)\n    }\n    default: {\n      const _: never = block\n      return null\n    }\n  }\n}\n\nexport function findPreviousVisibleSibling(\n  block: Exclude<Block, UsingBlock>,\n): DOMElement | Text | null {\n  const child = findPreviousVisibleSiblingBlock(block)\n  if (child) return child.value\n  return null\n}\n","export function assert(condition: any, msg: string): asserts condition {\n  if (!condition) throw Error(msg)\n}\n\nexport function assertClosure(\n  currentActor: any,\n  methodName: string,\n): asserts currentActor {\n  if (!currentActor)\n    throw Error(`${methodName}() called outside from using() closure`)\n}\n","import {launch, createEvent} from 'effector'\n\nimport type {\n  DOMElement,\n  Leaf,\n  BindingsDraft,\n  LeafData,\n  Env,\n  LeafDataElement,\n  Template,\n} from './index.h'\n\nimport type {\n  ElementBlock,\n  ListBlock,\n  TextBlock,\n  RouteBlock,\n  FragmentParent,\n  RecItemBlock,\n  RecBlock,\n  BlockBlock,\n  BlockItemBlock,\n} from './relation.h'\n\nimport {createOpGroup, createOp} from './plan'\n\nimport {spawn, currentTemplate} from './template'\nimport {findParentDOMElement, findPreviousVisibleSibling} from './search'\nimport {applyStaticOps} from './bindings'\nimport {assert} from './assert'\n\nexport function setInParentIndex(template: Template) {\n  if (!currentTemplate) return\n  const {draft} = template\n  if (draft.type === 'listItem') return\n  if (draft.type === 'rec') return\n  switch (currentTemplate.draft.type) {\n    case 'element':\n    case 'using':\n    case 'route':\n    case 'list':\n    case 'rec':\n    case 'recItem':\n    case 'block':\n    case 'blockItem':\n      draft.inParentIndex = currentTemplate.draft.childCount\n      currentTemplate.draft.childCount += 1\n      currentTemplate.draft.childTemplates.push(template)\n      break\n    default:\n      console.warn(\n        `unexpected currentTemplate type ${currentTemplate.draft.type}`,\n      )\n  }\n}\n\nexport function mountChildTemplates(\n  draft: BindingsDraft,\n  {\n    parentBlockFragment,\n    leaf,\n    node,\n    svgRoot,\n    values,\n  }: {\n    parentBlockFragment: FragmentParent\n    leaf: Leaf\n    node?: DOMElement\n    svgRoot?: SVGSVGElement | null\n    values?: {[name: string]: any}\n  },\n) {\n  draft.childTemplates.forEach(actor => {\n    mountChild({\n      parentBlockFragment,\n      leaf,\n      node,\n      svgRoot,\n      values,\n      actor,\n    })\n  })\n}\nconst fragmentParentTypes: Array<FragmentParent['type']> = [\n  'LF',\n  'using',\n  'element',\n  'recItem',\n  'rec',\n  'block',\n  'blockItem',\n  'route',\n]\n\nexport function mountChild({\n  parentBlockFragment,\n  leaf,\n  node = leaf.mountNode,\n  actor,\n  svgRoot,\n  values,\n}: {\n  parentBlockFragment: FragmentParent\n  leaf: Leaf\n  node?: DOMElement\n  actor: Template\n  svgRoot?: SVGSVGElement | null\n  values?: {[name: string]: any}\n}) {\n  assert(\n    fragmentParentTypes.includes(parentBlockFragment.type),\n    `incorrect parent ${parentBlockFragment.type}`,\n  )\n  let leafData: LeafData\n  const {draft} = actor\n  const {queue} = leaf.root.leafOps[leaf.fullID].group\n  const opGroup = createOpGroup(queue)\n  const parentDomSubtree = leaf.root.leafOps[leaf.fullID].domSubtree\n  let domSubtree = parentDomSubtree\n  switch (draft.type) {\n    case 'route': {\n      const routeBlock: RouteBlock = {\n        type: 'route',\n        parent: parentBlockFragment,\n        child: [],\n        visible: false,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = routeBlock\n      leafData = {\n        type: 'route',\n        block: routeBlock,\n        ops: {},\n        initialized: false,\n        pendingInit: null,\n      }\n      break\n    }\n    case 'element': {\n      let element: DOMElement\n      if (actor.isBlock) {\n        let env: Env | void\n        let type: 'html' | 'svg' | void\n        let currentLeaf = leaf\n        while (currentLeaf && (!type || !env)) {\n          if (currentLeaf.template.env) env = currentLeaf.template.env\n          const {draft} = currentLeaf\n          if (draft.type === 'element') {\n            if (draft.tag === 'svg') {\n              type = 'svg'\n            } else if (draft.tag === 'foreignObject') {\n              type = 'html'\n            }\n          }\n          currentLeaf = currentLeaf.parent!\n        }\n        if (!type) type = 'html'\n        if (env) {\n          element =\n            type === 'svg'\n              ? env.document.createElementNS(\n                  'http://www.w3.org/2000/svg',\n                  draft.tag,\n                )\n              : env.document.createElement(draft.tag)\n          applyStaticOps(element, draft.staticSeq)\n        }\n      } else {\n        element = draft.stencil.cloneNode() as DOMElement\n      }\n      const elementBlock: ElementBlock = {\n        type: 'element',\n        parent: parentBlockFragment,\n        child: [],\n        value: element!,\n        visible: false,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = elementBlock\n      leafData = {\n        type: 'element',\n        block: elementBlock,\n        ops: {\n          visible: createOp({\n            value: false,\n            priority: 'tree',\n            runOp(value) {\n              if (leaf.hydration) {\n              }\n              if (value) {\n                appendChild(elementBlock)\n                const leafData_ = leafData as LeafDataElement\n                if (leafData_.needToCallNode) {\n                  leafData_.needToCallNode = false\n                  launch({\n                    target: onMount,\n                    params: {\n                      element: elementBlock.value,\n                      fns: draft.node,\n                    },\n                    page: childSpawn,\n                    //@ts-expect-error\n                    scope: leaf.root.scope,\n                  })\n                }\n                elementBlock.visible = true\n              } else {\n                elementBlock.value.remove()\n                elementBlock.visible = false\n              }\n            },\n            group: parentDomSubtree,\n          }),\n        },\n        needToCallNode: draft.node.length > 0,\n      }\n      domSubtree = createOpGroup(queue)\n      break\n    }\n    case 'list': {\n      const listBlock: ListBlock = {\n        type: 'list',\n        parent: parentBlockFragment,\n        child: [],\n        lastChild: null,\n        visible: true,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = listBlock\n      leafData = {\n        type: 'list',\n        draft,\n        block: listBlock,\n        records: [],\n        pendingUpdate: null,\n      }\n      break\n    }\n    case 'using':\n    case 'listItem':\n      break\n    case 'rec': {\n      const recBlock: RecBlock = {\n        type: 'rec',\n        parent: parentBlockFragment,\n        child: [],\n        visible: true,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = recBlock\n      leafData = {\n        type: 'rec',\n        block: recBlock,\n      }\n      break\n    }\n    case 'recItem': {\n      const recItemBlock: RecItemBlock = {\n        type: 'recItem',\n        parent: parentBlockFragment,\n        child: [],\n        visible: true,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = recItemBlock\n      leafData = {\n        type: 'rec item',\n        block: recItemBlock,\n      }\n      break\n    }\n    case 'block': {\n      const block: BlockBlock = {\n        type: 'block',\n        parent: parentBlockFragment,\n        child: [],\n        visible: true,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = block\n      leafData = {\n        type: 'block',\n        block,\n      }\n      break\n    }\n    case 'blockItem': {\n      const block: BlockItemBlock = {\n        type: 'blockItem',\n        parent: parentBlockFragment,\n        child: [],\n        visible: true,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = block\n      leafData = {\n        type: 'block item',\n        block: block,\n      }\n      break\n    }\n    default: {\n      //@ts-expect-error\n      console.warn(`unexpected draft type ${draft.type}`)\n    }\n  }\n  const childSpawn = spawn(actor, {\n    values,\n    parentLeaf: leaf,\n    mountNode: node,\n    svgRoot: svgRoot ? svgRoot : leaf.svgRoot,\n    //@ts-expect-error\n    leafData,\n    opGroup,\n    domSubtree,\n    hydration: leaf.hydration,\n    root: leaf.root,\n  })\n}\n\nexport function appendChild(block: TextBlock | ElementBlock) {\n  const visibleSibling = findPreviousVisibleSibling(block)\n  if (visibleSibling) {\n    visibleSibling.after(block.value)\n  } else {\n    const parent = findParentDOMElement(block)\n    parent!.prepend(block.value)\n  }\n  block.visible = true\n}\n\n//@ts-expect-error\nexport const onMount = createEvent<{\n  fns: Array<(node: DOMElement) => (() => void) | void>\n  element: DOMElement\n}>({named: 'onMount'})\n\nonMount.watch(({fns, element}) => {\n  fns.forEach(fn => {\n    fn(element)\n  })\n})\n","import {Store, Event, sample} from 'effector'\n\nexport function mutualSample<Mount, State, T>({\n  mount,\n  state,\n  onMount,\n  onState,\n}: {\n  mount: Event<Mount>\n  state: Store<State>\n  onMount: (state: State, mount: Mount) => T\n  onState: (mount: Mount, state: State) => T\n}): {\n  onMount: Event<T>\n  onState: Event<T>\n} {\n  return {\n    onMount: sample({\n      source: state,\n      clock: mount,\n      fn: onMount,\n      greedy: true,\n    }),\n    onState: sample({\n      source: mount,\n      clock: state,\n      fn: onState,\n      greedy: true,\n    }),\n  }\n}\n","export function forIn<T extends Record<string, unknown>>(\n  obj: T,\n  cb: (value: T[keyof T], key: Exclude<keyof T, number>) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key as any)\n  }\n}\n","import {Event, is} from 'effector'\n\nimport {currentTemplate} from '../template'\nimport {assert} from '../assert'\n\nexport function handler(\n  map: Partial<\n    {[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}\n  >,\n): void\nexport function handler(\n  options: {\n    passive?: boolean\n    capture?: boolean\n    prevent?: boolean\n    stop?: boolean\n  },\n  map: Partial<\n    {[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}\n  >,\n): void\nexport function handler(options: any, map?: any) {\n  if (!currentTemplate) return\n  const draft = currentTemplate.draft\n  assert(\n    draft.type === 'element',\n    `\"handler\" extension can be used only with element nodes, got \"${draft.type}\"`,\n  )\n  if (map === undefined) {\n    map = options\n    options = {}\n  }\n  for (const key in map) {\n    assert(is.unit(map[key]), `handler for \"${key}\" should be event`)\n  }\n  const {\n    passive = false,\n    capture = false,\n    prevent = false,\n    stop = false,\n  } = options\n  draft.handler.push({\n    options: {\n      prevent,\n      stop,\n    },\n    domConfig: {\n      passive: prevent ? false : passive,\n      capture,\n    },\n    map,\n  })\n}\n","import type {Store, Event} from 'effector'\n\nimport type {\n  PropertyMap,\n  StoreOrData,\n  DOMProperty,\n  StylePropertyMap,\n} from '../index.h'\n\nimport {escapeTag} from '../bindings'\nimport {currentTemplate} from '../template'\nimport {assertClosure} from '../assert'\nimport {handler} from './handler'\n\nexport function spec(config: {\n  attr?: PropertyMap\n  data?: PropertyMap\n  text?: StoreOrData<DOMProperty> | Array<StoreOrData<DOMProperty>>\n  style?: StylePropertyMap\n  styleVar?: PropertyMap\n  visible?: Store<boolean>\n  handler?:\n    | {\n        config?: {\n          passive?: boolean\n          capture?: boolean\n          prevent?: boolean\n          stop?: boolean\n        }\n        on: Partial<\n          {[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}\n        >\n      }\n    | Partial<{[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}>\n  ɔ?: any\n}) {\n  assertClosure(currentTemplate, 'spec')\n  const draft = currentTemplate.draft\n  switch (draft.type) {\n    case 'list':\n      if (config.visible) draft.itemVisible = config.visible\n      return\n    case 'listItem':\n    case 'using':\n    case 'route':\n    case 'rec':\n    case 'recItem':\n    case 'block':\n    case 'blockItem':\n      return\n  }\n  if (config.attr) draft.attr.push(config.attr)\n  if (config.data) draft.data.push(config.data)\n  if ('text' in config) {\n    const text = config.text\n    const firstIndex = draft.childCount\n    if (Array.isArray(text)) {\n      draft.text.push(\n        ...text.map((value, i) => ({\n          index: i + firstIndex,\n          value,\n        })),\n      )\n      draft.childCount += text.length\n    } else {\n      draft.text.push({\n        index: firstIndex,\n        value: text!,\n      })\n      draft.childCount += 1\n    }\n  }\n  if (config.style) {\n    const escaped = {} as StylePropertyMap\n    for (const field in config.style) {\n      //@ts-expect-error\n      escaped[escapeTag(field)] = config.style[field]\n    }\n    draft.style.push(escaped)\n  }\n  if (config.styleVar) draft.styleVar.push(config.styleVar)\n  if (config.visible) draft.visible = config.visible\n  if (config.handler) {\n    const handlerDef = config.handler\n    //@ts-expect-error\n    if (typeof handlerDef.on === 'object') {\n      //@ts-expect-error\n      handler(handlerDef.config || {}, handlerDef.on)\n    } else {\n      //@ts-expect-error\n      handler(handlerDef)\n    }\n  }\n  if (config.ɔ) {\n    spec(config.ɔ)\n  }\n}\n","import {Store, Event, is, launch, createEvent, sample, merge} from 'effector'\n\nimport type {StateRef} from '../../effector/index.h'\n\nimport type {\n  DOMElement,\n  ElementDraft,\n  NSType,\n  PropertyMap,\n  StoreOrData,\n  DOMProperty,\n  StylePropertyMap,\n  Leaf,\n  LeafDataElement,\n  Template,\n  HandlerRecord,\n  PropertyOperationDef,\n  PropertyOperationKind,\n} from '../index.h'\n\nimport type {ElementBlock, TextBlock} from '../relation.h'\n\nimport {pushOpToQueue, forceSetOpValue, createOp} from '../plan'\n\nimport {\n  applyStyle,\n  applyStyleVar,\n  applyDataAttr,\n  applyAttr,\n  applyText,\n  applyStaticOps,\n} from '../bindings'\nimport {createTemplate, currentTemplate} from '../template'\nimport {\n  findParentDOMElement,\n  findPreviousVisibleSibling,\n  findPreviousVisibleSiblingBlock,\n} from '../search'\nimport {\n  appendChild,\n  onMount as onMountSync,\n  mountChildTemplates,\n  setInParentIndex,\n} from '../mountChild'\nimport {assertClosure} from '../assert'\nimport {mutualSample} from '../mutualSample'\nimport {forIn} from '../forIn'\nimport {spec} from './spec'\n\nfunction createPropsOp<T, S>(\n  draft: ElementDraft,\n  {\n    initCtx,\n    runOp,\n    hooks: {onMount, onState},\n  }: {\n    initCtx(value: T, leaf: Leaf): S\n    runOp(value: T, ctx: S): void\n    hooks: {\n      onMount: Event<{leaf: Leaf; value: T}>\n      onState: Event<{leaf: Leaf; value: T}>\n    }\n  },\n) {\n  const opID = draft.opsAmount++\n  onMount.watch(({value, leaf}) => {\n    const op = createOp({\n      value,\n      priority: 'props',\n      runOp(value) {\n        runOp(value, ctx)\n      },\n      group: leaf.root.leafOps[leaf.fullID].group,\n    })\n    leaf.root.leafOps[leaf.fullID].group.ops[opID] = op\n    const ctx = initCtx(value, leaf)\n  })\n  onState.watch(({value, leaf}) => {\n    pushOpToQueue(value, leaf.root.leafOps[leaf.fullID].group.ops[opID])\n  })\n}\n\nconst syncOperations: Array<{\n  field: string\n  type: PropertyOperationKind\n}> = [\n  {type: 'attr', field: 'value'},\n  {type: 'attr', field: 'checked'},\n  {type: 'attr', field: 'min'},\n  {type: 'attr', field: 'max'},\n]\n\nconst propertyOperationBinding: Record<\n  PropertyOperationKind,\n  (\n    element: DOMElement,\n    field: string,\n    value: string | number | boolean | null,\n  ) => void\n> = {\n  attr: applyAttr,\n  data: applyDataAttr,\n  style: applyStyle,\n  styleVar: applyStyleVar,\n}\n\nconst readElement = (leaf: Leaf) => (leaf.data as LeafDataElement).block.value\n\n/** operation family for things represented as <el \"thing\"=\"value\" /> */\nfunction propertyMapToOpDef(\n  draft: ElementDraft,\n  type: PropertyOperationKind,\n  ops: {\n    attr: PropertyMap\n    data: PropertyMap\n    style: StylePropertyMap\n    styleVar: PropertyMap\n  },\n) {\n  draft[type].forEach(record => {\n    forIn(record as unknown as PropertyMap, (value, key) => {\n      switch (type) {\n        case 'data':\n        case 'styleVar':\n          ops[type][key] = value\n          break\n        case 'attr':\n          ops.attr[key === 'xlink:href' ? 'href' : key] = value\n          break\n        case 'style':\n          if (key.startsWith('--')) {\n            ops.styleVar[key.slice(2)] = value\n          } else {\n            //@ts-expect-error inconsistency in StylePropertyMap key type\n            ops.style[key] = value\n          }\n          break\n      }\n    })\n  })\n}\n\nfunction installTextNode(leaf: Leaf, value: string, childIndex: number) {\n  const parentBlock = leaf.data.block as ElementBlock\n  const textBlock: TextBlock = {\n    type: 'text',\n    parent: parentBlock,\n    visible: false,\n    index: childIndex,\n    //@ts-expect-error\n    value: null,\n  }\n  parentBlock.child[childIndex] = textBlock\n  if (leaf.hydration) {\n    const siblingBlock = findPreviousVisibleSiblingBlock(textBlock)\n    if (siblingBlock) {\n      switch (siblingBlock.type) {\n        case 'text': {\n          textBlock.value = leaf.root.env.document.createTextNode(value)\n          siblingBlock.value.after(textBlock.value)\n          break\n        }\n        case 'element': {\n          textBlock.value = siblingBlock.value.nextSibling! as Text\n          applyText(textBlock.value, value)\n          break\n        }\n      }\n    } else {\n      const parentElement = findParentDOMElement(textBlock)\n      textBlock.value = parentElement!.firstChild! as Text\n      applyText(textBlock.value, value)\n    }\n    textBlock.visible = true\n  } else {\n    textBlock.value = leaf.root.env.document.createTextNode(value)\n    appendChild(textBlock)\n  }\n  return textBlock\n}\n\nfunction processStoreRef(store: Store<any>) {\n  //@ts-expect-error\n  const ref: StateRef = store.stateRef\n  const templ: Template = currentTemplate!\n  if (!templ.plain.includes(ref) && !templ.closure.includes(ref)) {\n    templ.closure.push(ref)\n  }\n}\nexport function h(tag: string): void\nexport function h(tag: string, cb: () => void): void\nexport function h(\n  tag: string,\n  spec: {\n    fn?: () => void\n    attr?: PropertyMap\n    data?: PropertyMap\n    text?: StoreOrData<DOMProperty> | Array<StoreOrData<DOMProperty>>\n    visible?: Store<boolean>\n    style?: StylePropertyMap\n    styleVar?: PropertyMap\n    handler?:\n      | {\n          config?: {\n            passive?: boolean\n            capture?: boolean\n            prevent?: boolean\n            stop?: boolean\n          }\n          on: Partial<\n            {[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}\n          >\n        }\n      | Partial<\n          {[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}\n        >\n  },\n): void\nexport function h(tag: string, opts?: any) {\n  let hasCb = false\n  let hasOpts = false\n  let cb: () => void\n  if (typeof opts === 'function') {\n    hasCb = true\n    cb = opts\n  } else {\n    if (opts) {\n      hasOpts = true\n      if (opts.fn) {\n        hasCb = true\n        cb = opts.fn\n      }\n      if (opts.ɔ) {\n        if (typeof opts.ɔ === 'function') {\n          hasCb = true\n          cb = opts.ɔ\n        } else if (typeof opts.ɔ.fn === 'function') {\n          hasCb = true\n          cb = opts.ɔ.fn\n        }\n      }\n    }\n  }\n  assertClosure(currentTemplate, 'h')\n  const env = currentTemplate.env\n  const parentNS = currentTemplate.namespace\n  let ns: NSType = parentNS\n  let type = 'html'\n  ns = type = parentNS === 'svg' ? 'svg' : 'html'\n  if (tag === 'svg') {\n    type = 'svg'\n    ns = 'svg'\n  }\n  let node: DOMElement\n  if (!currentTemplate.isBlock) {\n    node =\n      type === 'svg'\n        ? env.document.createElementNS('http://www.w3.org/2000/svg', tag)\n        : env.document.createElement(tag)\n  }\n  const stencil = node!\n  const draft: ElementDraft = {\n    type: 'element',\n    tag,\n    attr: [],\n    data: [],\n    text: [],\n    style: [],\n    styleVar: [],\n    handler: [],\n    stencil,\n    seq: [],\n    staticSeq: [],\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: -1,\n    opsAmount: 1,\n    node: [],\n  }\n  if (parentNS === 'foreignObject') {\n    draft.attr.push({\n      xmlns: 'http://www.w3.org/1999/xhtml',\n    })\n    ns = 'html'\n  } else if (tag === 'svg') {\n    draft.attr.push({\n      xmlns: 'http://www.w3.org/2000/svg',\n    })\n    ns = 'svg'\n  } else if (tag === 'foreignObject') {\n    ns = 'foreignObject'\n  }\n\n  const elementTemplate = createTemplate({\n    name: 'element',\n    draft,\n    isSvgRoot: tag === 'svg',\n    namespace: ns,\n    fn(_, {mount}) {\n      //@ts-expect-error\n      const domElementCreated = createEvent<Leaf>({named: 'domElementCreated'})\n\n      if (hasCb) {\n        cb()\n      }\n      if (hasOpts) {\n        spec(opts)\n      }\n      if (is.unit(draft.visible)) {\n        draft.seq.push({type: 'visible', value: draft.visible})\n        processStoreRef(draft.visible)\n      }\n      const ops: {\n        attr: PropertyMap\n        data: PropertyMap\n        style: StylePropertyMap\n        styleVar: PropertyMap\n      } = {\n        attr: {},\n        data: {},\n        style: {},\n        styleVar: {},\n      }\n      propertyMapToOpDef(draft, 'attr', ops)\n      propertyMapToOpDef(draft, 'data', ops)\n      propertyMapToOpDef(draft, 'style', ops)\n      propertyMapToOpDef(draft, 'styleVar', ops)\n      forIn(ops, (opsMap, type) => {\n        forIn(opsMap as unknown as PropertyMap, (value, field) => {\n          if (is.unit(value)) {\n            draft.seq.push({type, field, value})\n            processStoreRef(value)\n          } else {\n            draft.staticSeq.push({type, field, value})\n          }\n        })\n      })\n      draft.text.forEach(item => {\n        if (item.value === null) return\n        if (is.unit(item.value)) {\n          draft.seq.push({\n            type: 'dynamicText',\n            value: item.value,\n            childIndex: item.index,\n          })\n          processStoreRef(item.value)\n        } else {\n          draft.seq.push({\n            type: 'staticText',\n            value: String(item.value),\n            childIndex: item.index,\n          })\n        }\n      })\n      draft.handler.forEach(item => {\n        forIn(item.map, (handler, key) => {\n          draft.seq.push({\n            type: 'handler',\n            for: key,\n            //@ts-expect-error\n            handler,\n            options: item.options,\n            domConfig: item.domConfig,\n          })\n        })\n      })\n      if (stencil) applyStaticOps(stencil, draft.staticSeq)\n      draft.seq.forEach(item => {\n        switch (item.type) {\n          case 'visible': {\n            const {onMount, onState} = mutualSample({\n              mount,\n              state: item.value,\n              onMount: (value, leaf) => ({\n                leaf,\n                value,\n                hydration: leaf.hydration,\n              }),\n              onState: (leaf, value) => ({leaf, value, hydration: false}),\n            })\n            onMount.watch(({leaf, value, hydration}) => {\n              const leafData = leaf.data as LeafDataElement\n              const visibleOp = leafData.ops.visible\n              const parentBlock = leafData.block\n              if (hydration) {\n                forceSetOpValue(value, visibleOp)\n                if (value) {\n                  const visibleSibling = findPreviousVisibleSibling(parentBlock)\n                  let foundElement: DOMElement\n                  if (visibleSibling) {\n                    foundElement = visibleSibling.nextSibling! as DOMElement\n                  } else {\n                    foundElement = findParentDOMElement(parentBlock)!\n                      .firstChild! as DOMElement\n                  }\n                  if (foundElement.nodeName === '#text') {\n                    const emptyText = foundElement\n                    foundElement = foundElement.nextSibling! as DOMElement\n                    emptyText.remove()\n                  }\n                  parentBlock.value = foundElement\n                  parentBlock.visible = true\n                }\n              }\n              const svgRoot = elementTemplate.isSvgRoot\n                ? (parentBlock.value as SVGSVGElement)\n                : null\n              mountChildTemplates(draft, {\n                parentBlockFragment: parentBlock,\n                leaf,\n                node: parentBlock.value,\n                svgRoot,\n              })\n              if (value) {\n                if (leafData.needToCallNode) {\n                  leafData.needToCallNode = false\n                  launch({\n                    target: onMountSync,\n                    params: {\n                      element: leafData.block.value,\n                      fns: draft.node,\n                    },\n                    page: leaf,\n                    defer: true,\n                    //@ts-expect-error\n                    scope: leaf.root.scope,\n                  })\n                }\n              }\n              launch({\n                target: domElementCreated,\n                params: leaf,\n                defer: true,\n                page: leaf,\n                //@ts-expect-error\n                scope: leaf.root.scope,\n              })\n            })\n            merge([onState, onMount]).watch(({leaf, value, hydration}) => {\n              const leafData = leaf.data as LeafDataElement\n              const visibleOp = leafData.ops.visible\n              if (!hydration) {\n                pushOpToQueue(value, visibleOp)\n              }\n            })\n            break\n          }\n          case 'attr':\n          case 'data':\n          case 'style':\n          case 'styleVar': {\n            const fn = propertyOperationBinding[item.type]\n            const immediate = syncOperations.some(\n              ({type, field}) => item.type === type && item.field === field,\n            )\n            const hooks = mutualSample({\n              mount: domElementCreated,\n              state: item.value,\n              onMount: (value, leaf) => ({leaf, value}),\n              onState: (leaf, value) => ({leaf, value}),\n            })\n            if (immediate) {\n              merge([hooks.onState, hooks.onMount]).watch(({leaf, value}) => {\n                fn(readElement(leaf), item.field, value)\n              })\n            } else {\n              createPropsOp(draft, {\n                initCtx(value: DOMProperty, leaf) {\n                  const element = readElement(leaf)\n                  fn(element, item.field, value)\n                  return element\n                },\n                runOp(value, element: DOMElement) {\n                  fn(element, item.field, value)\n                },\n                hooks,\n              })\n            }\n            break\n          }\n          case 'dynamicText':\n            createPropsOp(draft, {\n              initCtx(value: string, leaf) {\n                return installTextNode(leaf, value, item.childIndex)\n              },\n              runOp(value, ctx: TextBlock) {\n                applyText(ctx.value, value)\n              },\n              hooks: mutualSample({\n                mount: domElementCreated,\n                state: item.value,\n                onMount: (value, leaf) => ({leaf, value: String(value)}),\n                onState: (leaf, value) => ({leaf, value: String(value)}),\n              }),\n            })\n            break\n          case 'staticText':\n            domElementCreated.watch(leaf => {\n              installTextNode(leaf, item.value, item.childIndex)\n            })\n            break\n          case 'handler': {\n            const handlerTemplate: Template | null =\n              //@ts-expect-error\n              item.handler.graphite.meta.nativeTemplate || null\n            domElementCreated.watch(leaf => {\n              let page: Leaf | null = null\n              if (handlerTemplate) {\n                let handlerPageFound = false\n                let currentPage: Leaf | null = leaf\n                while (!handlerPageFound && currentPage) {\n                  if (currentPage.template === handlerTemplate) {\n                    handlerPageFound = true\n                    page = currentPage\n                  } else {\n                    currentPage = currentPage.parent\n                  }\n                }\n              } else {\n                page = null //leaf\n              }\n              readElement(leaf).addEventListener(\n                item.for,\n                value => {\n                  if (item.options.prevent) value.preventDefault()\n                  if (item.options.stop) value.stopPropagation()\n                  launch({\n                    target: item.handler,\n                    params: value,\n                    page,\n                    //@ts-expect-error\n                    scope: leaf.root.scope,\n                  })\n                },\n                item.domConfig,\n              )\n            })\n            break\n          }\n        }\n      })\n      mount.watch(leaf => {\n        const leafData = leaf.data as LeafDataElement\n        if (!draft.visible) {\n          const visibleOp = leafData.ops.visible\n          const parentBlock = leafData.block\n          if (leaf.hydration) {\n            forceSetOpValue(true, visibleOp)\n            const visibleSibling = findPreviousVisibleSibling(parentBlock)\n            let foundElement: DOMElement\n            if (visibleSibling) {\n              foundElement = visibleSibling.nextSibling! as DOMElement\n            } else {\n              foundElement = findParentDOMElement(parentBlock)!\n                .firstChild! as DOMElement\n            }\n            if (foundElement.nodeName === '#text') {\n              const emptyText = foundElement\n              foundElement = foundElement.nextSibling! as DOMElement\n              emptyText.remove()\n            }\n            parentBlock.value = foundElement\n            parentBlock.visible = true\n          }\n          const svgRoot = elementTemplate.isSvgRoot\n            ? (parentBlock.value as SVGSVGElement)\n            : null\n          mountChildTemplates(draft, {\n            parentBlockFragment: parentBlock,\n            leaf,\n            node: parentBlock.value,\n            svgRoot,\n          })\n          launch({\n            target: domElementCreated,\n            params: leaf,\n            defer: true,\n            page: leaf,\n            //@ts-expect-error\n            scope: leaf.root.scope,\n          })\n          if (leaf.hydration) {\n            if (leafData.needToCallNode) {\n              leafData.needToCallNode = false\n              launch({\n                target: onMountSync,\n                params: {\n                  element: leafData.block.value,\n                  fns: draft.node,\n                },\n                page: leaf,\n                defer: true,\n                //@ts-expect-error\n                scope: leaf.root.scope,\n              })\n            }\n          } else {\n            pushOpToQueue(true, visibleOp)\n          }\n        }\n      })\n    },\n    env,\n  })\n  setInParentIndex(elementTemplate)\n}\n","import type {Scope} from '../../effector/unit.h'\n\nimport type {\n  DOMElement,\n  NSType,\n  UsingDraft,\n  Leaf,\n  Root,\n  Template,\n} from '../index.h'\n\nimport type {UsingBlock} from '../relation.h'\n\nimport {createOpGroup, createOpQueue} from '../plan'\n\nimport {createTemplate, spawn, currentLeaf} from '../template'\nimport {assert} from '../assert'\nimport {mountFn} from '../mountFn'\n\nfunction getDefaultEnv(): {\n  document: Document\n} {\n  if (typeof document !== 'undefined') return {document}\n  throw Error('your environment has no document')\n}\nexport function using(node: DOMElement, cb: () => any): void\nexport function using(\n  node: DOMElement,\n  opts: {\n    fn: () => void\n    hydrate?: boolean\n    env?: {\n      document: Document\n    }\n    onComplete?: () => void\n    onRoot?: (config: {template: Template; leaf: Leaf}) => void\n    scope?: Scope\n  },\n): void\nexport function using(node: DOMElement, opts: any): void {\n  let cb: () => any\n  let onComplete: (() => void) | undefined\n  let env: {\n    document: Document\n  }\n  let hydrate: boolean\n  let onRoot: ((config: {template: Template; leaf: Leaf}) => void) | undefined\n  let scope: Scope\n  if (typeof opts === 'function') {\n    cb = opts\n    env = getDefaultEnv()\n    hydrate = false\n  } else if (opts) {\n    cb = opts.fn\n    env = opts.env ? opts.env : getDefaultEnv()\n    hydrate = opts.hydrate\n    onComplete = opts.onComplete\n    onRoot = opts.onRoot\n    scope = opts.scope\n  } else throw Error('using() second argument is missing')\n  assert(node, 'using() first argument is missing')\n  const root: Root = {\n    scope: scope!,\n    env,\n    activeSpawns: new Set(),\n    childSpawns: {},\n    leafOps: {},\n  }\n  const namespaceURI = node.namespaceURI\n  const tag = node.tagName.toLowerCase()\n  const ns: NSType =\n    namespaceURI === 'http://www.w3.org/2000/svg'\n      ? 'svg'\n      : tag === 'foreignobject'\n      ? 'foreignObject'\n      : 'html'\n  const draft: UsingDraft = {\n    type: 'using',\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: -1,\n  }\n  const usingTemplate = createTemplate({\n    name: 'using',\n    draft,\n    isSvgRoot: tag === 'svg',\n    namespace: ns,\n    fn(_, {mount}) {\n      cb()\n      mount.watch(mountFn.using)\n    },\n    env,\n  })\n\n  const usingBlock: UsingBlock = {\n    type: 'using',\n    child: [],\n    value: node,\n  }\n  const queue = createOpQueue({onComplete})\n  const rootLeaf = spawn(usingTemplate, {\n    parentLeaf: currentLeaf || null,\n    mountNode: node,\n    svgRoot: usingTemplate.isSvgRoot\n      ? (node as SVGSVGElement)\n      : currentLeaf\n      ? currentLeaf.svgRoot\n      : null,\n    leafData: {\n      type: 'using',\n      draft,\n      element: node,\n      block: usingBlock,\n    },\n    opGroup: createOpGroup(queue),\n    domSubtree: createOpGroup(queue),\n    hydration: hydrate,\n    root,\n  })\n\n  if (onRoot) {\n    onRoot({\n      template: usingTemplate,\n      leaf: rootLeaf,\n    })\n  }\n  if (queue.onDrain && !queue.rafID) {\n    const rs = queue.onDrain\n    queue.onDrain = null\n    rs()\n  }\n}\n","import {launch} from 'effector'\nimport type {Leaf} from './index.h'\nimport {pushOpToQueue} from './plan'\n\nexport function iterateChildLeafs(leaf: Leaf, cb: (child: Leaf) => void) {\n  const childSpawns = leaf.root.childSpawns[leaf.fullID]\n  for (const key in childSpawns) {\n    const childs = childSpawns[key]\n    for (let i = 0; i < childs.length; i++) {\n      cb(childs[i])\n    }\n  }\n}\n\nexport function changeChildLeafsVisible(visible: boolean, leaf: Leaf) {\n  const childLeafIterator = (child: Leaf) => {\n    const data = child.data\n    if (visible && data.type === 'list' && data.pendingUpdate) {\n      const update = data.pendingUpdate\n      data.pendingUpdate = null\n      launch({\n        target: child.template.api.pendingUpdate,\n        params: update,\n        defer: true,\n        page: child,\n        //@ts-expect-error\n        scope: child.root.scope,\n      })\n    }\n    if (visible && data.type === 'route') {\n      if (data.pendingInit) {\n        const update = data.pendingInit.value\n        data.pendingInit = null\n        launch({\n          target: child.template.api.pendingInit,\n          params: update,\n          defer: true,\n          page: child,\n          //@ts-expect-error\n          scope: child.root.scope,\n        })\n      } else if (!data.block.visible) return\n    }\n    switch (data.type) {\n      case 'element':\n        pushOpToQueue(visible, data.ops.visible)\n        break\n      case 'route':\n      case 'list':\n      case 'list item':\n        iterateChildLeafs(child, childLeafIterator)\n        break\n      default:\n        console.log('unsupported type', data.type)\n    }\n  }\n  iterateChildLeafs(leaf, childLeafIterator)\n}\n","import type {Leaf} from './index.h'\n\nimport {pushOpToQueue} from './plan'\nimport {iterateChildLeafs} from './iterateChildLeafs'\n\nfunction unmountChildLeafsNoEvent(leaf: Leaf) {\n  leaf.root.activeSpawns.delete(leaf.fullID)\n  iterateChildLeafs(leaf, unmountLeafTree)\n}\n\nfunction unmountOwnSpawn(leaf: Leaf) {\n  removeItem(leaf, leaf.root.childSpawns[leaf.parent!.fullID][leaf.template.id])\n  removeItem(leaf, leaf.template.pages)\n}\n\nexport function unmountLeafTree(leaf: Leaf) {\n  const {data, root} = leaf\n  switch (data.type) {\n    case 'element': {\n      removeItem(leaf, root.childSpawns[leaf.parent!.fullID][leaf.template.id])\n      function halt(leaf: Leaf) {\n        root.activeSpawns.delete(leaf.fullID)\n        const childSpawns = root.childSpawns[leaf.fullID]\n        delete root.childSpawns[leaf.fullID]\n        delete root.leafOps[leaf.fullID]\n        removeItem(leaf, leaf.template.pages)\n        for (const id in childSpawns) {\n          childSpawns[id].forEach(halt)\n        }\n      }\n      halt(leaf)\n\n      const visibleOp = data.ops.visible\n      pushOpToQueue(false, visibleOp)\n      break\n    }\n    case 'list': {\n      const records = data.records\n      for (let i = 0; i < records.length; i++) {\n        const item = records[i]\n\n        if (item.instance) {\n          unmountLeafTree(item.instance)\n        }\n        item.active = false\n      }\n      leaf.root.activeSpawns.delete(leaf.fullID)\n      unmountOwnSpawn(leaf)\n      break\n    }\n    case 'list item': {\n      const listItemBlock = data.block\n      removeItem(listItemBlock, listItemBlock.parent.child)\n      const leftBlock = listItemBlock.left\n      const rightBlock = listItemBlock.right\n      if (leftBlock) {\n        leftBlock.right = rightBlock\n        if (!rightBlock && listItemBlock.parent.lastChild === listItemBlock) {\n          listItemBlock.parent.lastChild = leftBlock\n        }\n      }\n      if (rightBlock) {\n        rightBlock.left = leftBlock\n      }\n      if (\n        !leftBlock &&\n        !rightBlock &&\n        listItemBlock.parent.lastChild === listItemBlock\n      ) {\n        listItemBlock.parent.lastChild = null\n      }\n      listItemBlock.left = null\n      listItemBlock.right = null\n      unmountChildLeafsNoEvent(leaf)\n      unmountOwnSpawn(leaf)\n      break\n    }\n    // including route item\n    case 'route':\n      unmountChildLeafsNoEvent(leaf)\n      unmountOwnSpawn(leaf)\n      break\n    case 'block':\n    case 'block item':\n    case 'rec':\n    case 'rec item':\n      unmountChildLeafsNoEvent(leaf)\n      break\n    case 'using':\n      break\n    default: {\n      const _: never = data\n    }\n  }\n  delete root.childSpawns[leaf.fullID]\n  delete root.leafOps[leaf.fullID]\n}\n\nfunction removeItem<T>(item: T, list?: T[]) {\n  if (!list) return\n  const index = list.indexOf(item)\n  if (index !== -1) {\n    list.splice(index, 1)\n  }\n}\n","import type {Store} from 'effector'\n\nexport function remap<T extends {[field: string]: any}, S extends keyof T>(\n  store: Store<T>,\n  key: S,\n): Store<T[S]>\nexport function remap<\n  T extends {[field: string]: any},\n  S extends {[field: number]: keyof T} | {[field: string]: keyof T},\n>(\n  store: Store<T>,\n  shape: S,\n): {[K in keyof S]: S[K] extends keyof T ? Store<T[S[K]]> : never}\n\nexport function remap(\n  store: Store<any>,\n  shape: string | Array<any> | {[field: string]: any},\n) {\n  if (Array.isArray(shape)) {\n    return shape.map(key => store.map(value => value[key]))\n  }\n  if (typeof shape === 'object' && shape !== null) {\n    const result = {} as any\n    for (const key in shape) {\n      const projectedKey = shape[key]\n      result[key] = store.map(\n        typeof projectedKey === 'function'\n          ? value => projectedKey(value)\n          : value => value[projectedKey],\n      )\n    }\n    return result\n  }\n  return store.map(value => value[shape])\n}\n","import {\n  Store,\n  Event,\n  is,\n  launch,\n  createStore,\n  createEvent,\n  sample,\n} from 'effector'\n\nimport type {ListItemType, ListType, LeafDataList, Leaf} from '../index.h'\nimport type {LF} from '../relation.h'\n\nimport {beginMark, endMark} from '../platform/mark'\nimport {\n  createOpGroup,\n  createAsyncValue,\n  stopAsyncValue,\n  updateAsyncValue,\n} from '../plan'\nimport {createTemplate, spawn, currentTemplate} from '../template'\nimport {mountChildTemplates, setInParentIndex} from '../mountChild'\nimport {unmountLeafTree} from '../unmount'\nimport {assertClosure} from '../assert'\nimport {mountFn} from '../mountFn'\nimport {mutualSample} from '../mutualSample'\nimport {changeChildLeafsVisible} from '../iterateChildLeafs'\nimport {remap} from './remap'\n\nexport function list<T, K extends keyof T>(config: {\n  source: Store<T[]>\n  fn: (opts: {store: Store<T>; id: Store<T[K]>}) => void\n  key: T[K] extends string | number | symbol ? K : never\n}): void\nexport function list<T>(config: {\n  source: Store<T[]>\n  fn: (opts: {store: Store<T>; id: Store<number>}) => void\n}): void\nexport function list<T>(\n  source: Store<T[]>,\n  fn: (opts: {store: Store<T>; id: Store<number>}) => void,\n): void\nexport function list<T>(opts: any, maybeFn?: any) {\n  assertClosure(currentTemplate, 'list')\n  if (typeof maybeFn === 'function') {\n    if (is.unit(opts)) {\n      opts = {source: opts, fn: maybeFn}\n    } else {\n      opts.fn = maybeFn\n    }\n  }\n  const {fn: cb, key, source, fields = []} = opts\n  const getID: (item: T, i: number) => string | number | symbol =\n    key !== undefined\n      ? typeof key === 'function'\n        ? key\n        : (item: any, i: number) => item[key]\n      : (item, i) => i\n  const draft: ListType = {\n    type: 'list',\n    key: is.store(opts) ? {type: 'index'} : {type: 'key', key: opts.key},\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: -1,\n  }\n  const {env, namespace} = currentTemplate\n\n  const listTemplate = createTemplate({\n    name: 'list',\n    draft,\n    isSvgRoot: false,\n    namespace,\n    fn(_, {mount}) {\n      const listItemTemplate = createTemplate<{\n        itemUpdater: any\n      }>({\n        name: 'list item',\n        state: {id: -1, store: null},\n        draft,\n        isSvgRoot: false,\n        namespace,\n        fn({id, store}, {mount}) {\n          cb({store, key: id, fields: remap(store, fields)})\n          //@ts-expect-error\n          const itemUpdater = createEvent<any>({named: 'itemUpdater'})\n          store.on(itemUpdater, (_, e) => e)\n          if (draft.itemVisible) {\n            const {onMount: mountAndVisible, onState: onVisibleChanges} =\n              mutualSample({\n                mount,\n                state: draft.itemVisible,\n                onMount: (visible, leaf) => ({visible, leaf}),\n                onState: (leaf, visible) => ({visible, leaf}),\n              })\n            mountAndVisible.watch(({visible, leaf}) => {\n              const parentBlock = leaf.data.block as LF\n              parentBlock.visible = visible\n              parentBlock.childInitialized = visible\n              if (visible) {\n                mountChildTemplates(draft, {\n                  parentBlockFragment: parentBlock,\n                  leaf,\n                })\n              }\n            })\n            onVisibleChanges.watch(({visible, leaf}) => {\n              const parentBlock = leaf.data.block as LF\n              parentBlock.visible = visible\n              if (!parentBlock.childInitialized) {\n                if (visible) {\n                  parentBlock.childInitialized = true\n                  mountChildTemplates(draft, {\n                    parentBlockFragment: parentBlock,\n                    leaf,\n                  })\n                }\n                return\n              }\n              changeChildLeafsVisible(visible, leaf)\n            })\n          } else {\n            mount.watch(mountFn.listItem)\n          }\n          return {\n            itemUpdater,\n          }\n        },\n        env,\n      })\n      const updates = createStore<ListItemType[]>([])\n      const mappedUpdates = source.map((x: any) => x)\n      const mountData = sample({\n        source: source as Store<T[]>,\n        clock: mount,\n        fn: (data, leaf) => {\n          return {\n            updates: data,\n            leaf,\n            hydration: leaf.hydration,\n          }\n        },\n        greedy: true,\n      })\n\n      const pendingUpdate = createEvent<T[]>()\n      const parentNodeUpdateSpawn = sample({\n        source: mountData,\n        clock: [mappedUpdates, pendingUpdate] as [Store<T[]>, Event<T[]>],\n        fn: ({leaf}, updates: T[]) => ({\n          updates,\n          leaf,\n          hydration: false,\n        }),\n        greedy: true,\n      })\n      sample({\n        source: updates,\n        clock: [mountData, parentNodeUpdateSpawn],\n        greedy: true,\n        fn(\n          records: ListItemType[],\n          {updates: input, leaf, hydration},\n        ): ListItemType[] {\n          const listData = leaf.data as LeafDataList\n          let curLeaf: Leaf | null = leaf\n          while (curLeaf) {\n            if (curLeaf.data.type === 'route' && !curLeaf.data.block.visible) {\n              listData.pendingUpdate = input\n              //@ts-expect-error skip updates\n              return\n            }\n            curLeaf = curLeaf.parent\n          }\n          const parentBlock = listData.block\n          beginMark('list update [' + source.shortName + ']')\n          const skipNode: boolean[] = Array(input.length).fill(false)\n          const keys = input.map(getID)\n          const resultRecords: ListItemType[] = []\n          for (let i = 0; i < records.length; i++) {\n            const record = records[i]\n            const index = keys.indexOf(record.key)\n            if (index !== -1) {\n              resultRecords.push(record)\n              skipNode[index] = true\n              updateAsyncValue(input[index], record.asyncValue)\n            } else {\n              record.active = false\n              if (record.instance) {\n                unmountLeafTree(record.instance)\n              }\n              stopAsyncValue(record.asyncValue)\n            }\n          }\n          for (let i = 0; i < input.length; i++) {\n            if (skipNode[i]) continue\n            const value = input[i]\n            const id = keys[i]\n            const group = createOpGroup(\n              leaf.root.leafOps[leaf.fullID].group.queue,\n            )\n            const listItemBlock: LF = {\n              type: 'LF',\n              parent: parentBlock,\n              child: [],\n              childInitialized: false,\n              visible: false,\n              left: null,\n              right: null,\n            }\n            const item: ListItemType = {\n              type: 'listItem',\n              key: id as string,\n              index: id as number,\n              active: true,\n              leafData: {\n                type: 'list item',\n                block: listItemBlock,\n                listDraft: draft,\n              },\n              asyncValue: createAsyncValue({\n                value,\n                group,\n                onChange(value) {\n                  if (item.instance) {\n                    launch({\n                      target: item.instance.template.api.itemUpdater,\n                      params: value,\n                      defer: true,\n                      page: item.instance,\n                      //@ts-expect-error\n                      scope: item.instance.root.scope,\n                    })\n                  }\n                },\n                onInit(value) {\n                  if (!item.active) return\n                  if (hydration) return\n                  item.instance = spawn(listItemTemplate, {\n                    values: {\n                      id,\n                      store: value,\n                    },\n                    parentLeaf: leaf,\n                    mountNode: leaf.mountNode,\n                    svgRoot: leaf.svgRoot,\n                    leafData: item.leafData,\n                    opGroup: group,\n                    domSubtree: leaf.root.leafOps[leaf.fullID].domSubtree,\n                    hydration,\n                    root: leaf.root,\n                  })\n                },\n              }),\n            }\n            const inParentIndex = resultRecords.length\n            resultRecords.push(item)\n            const leftSibling =\n              inParentIndex > 0\n                ? resultRecords[inParentIndex - 1].leafData\n                : null\n\n            parentBlock.child.push(listItemBlock)\n            if (leftSibling) {\n              const leftBlock = leftSibling.block\n              listItemBlock.left = leftBlock\n              const rightBlock = leftBlock.right\n              if (rightBlock) {\n                rightBlock.left = listItemBlock\n                listItemBlock.right = rightBlock\n              } else {\n                parentBlock.lastChild = listItemBlock\n              }\n              leftBlock.right = listItemBlock\n            } else {\n              parentBlock.lastChild = listItemBlock\n            }\n            if (hydration) {\n              item.instance = spawn(listItemTemplate, {\n                values: {\n                  id,\n                  store: value,\n                },\n                parentLeaf: leaf,\n                mountNode: leaf.mountNode,\n                svgRoot: leaf.svgRoot,\n                leafData: item.leafData,\n                opGroup: group,\n                domSubtree: leaf.root.leafOps[leaf.fullID].domSubtree,\n                hydration,\n                root: leaf.root,\n              })\n            }\n          }\n          endMark('list update [' + source.shortName + ']')\n          if (resultRecords.length === 0) {\n            parentBlock.lastChild = null\n          }\n          listData.records = resultRecords\n          return resultRecords\n        },\n        target: updates,\n      })\n      return {pendingUpdate}\n    },\n    env,\n  })\n  setInParentIndex(listTemplate)\n}\n","import {Store, is, launch, createEvent, sample, merge, combine} from 'effector'\n\nimport type {Leaf, LeafDataRoute, RouteDraft} from '../index.h'\n\nimport {createTemplate, currentTemplate} from '../template'\nimport {mountChild, setInParentIndex} from '../mountChild'\nimport {assertClosure} from '../assert'\nimport {mountFn} from '../mountFn'\nimport {mutualSample} from '../mutualSample'\nimport {changeChildLeafsVisible} from '../iterateChildLeafs'\n\nexport function route<T>(config: {\n  source: Store<T>\n  visible: (value: T) => boolean\n  fn: (config: {store: Store<T>}) => void\n}): void\nexport function route<T, S extends T>(config: {\n  source: Store<T>\n  visible: (value: T) => value is S\n  fn: (config: {store: Store<S>}) => void\n}): void\nexport function route<T>(config: {\n  source: Store<T>\n  visible: Store<boolean>\n  fn: (config: {store: Store<T>}) => void\n}): void\nexport function route<T>({\n  source,\n  visible,\n  fn,\n}: {\n  source: Store<T>\n  visible: Store<boolean> | ((value: T) => boolean)\n  fn: (config: {store: Store<T>}) => void\n}) {\n  assertClosure(currentTemplate, 'route')\n  const draft: RouteDraft = {\n    type: 'route',\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: -1,\n  }\n  const {env, namespace} = currentTemplate\n  const routeTemplate = createTemplate({\n    name: 'route',\n    isSvgRoot: false,\n    namespace,\n    env,\n    draft,\n    fn(_, {mount}) {\n      let state: Store<{\n        value: T\n        visible: boolean\n      }>\n      if (is.store(visible)) {\n        state = combine({value: source, visible})\n      } else {\n        const visibleFn = visible as (value: T) => boolean\n        state = source.map(value => ({\n          value,\n          visible: visibleFn(value),\n        }))\n      }\n      const childDraft: RouteDraft = {\n        type: 'route',\n        childTemplates: [],\n        childCount: 0,\n        inParentIndex: -1,\n      }\n      const routeItemTemplate = createTemplate({\n        name: 'route item',\n        isSvgRoot: false,\n        namespace,\n        env,\n        draft: childDraft,\n        state: {store: null},\n        fn({store}, {mount}) {\n          //@ts-expect-error\n          const itemUpdater = createEvent<any>({named: 'itemUpdater'})\n          store.on(itemUpdater, (_, upd) => upd)\n          fn({store})\n          const onValueUpdate = sample({\n            source: mount,\n            clock: state,\n            fn: (leaf, {visible, value}) => ({\n              leaf,\n              visible,\n              value,\n            }),\n            greedy: true,\n          })\n          mount.watch(mountFn.routeItem)\n          onValueUpdate.watch(({leaf, visible, value}) => {\n            const data = leaf.data as LeafDataRoute\n            data.block.visible = visible\n            if (visible) {\n              launch({\n                target: itemUpdater,\n                params: value,\n                defer: true,\n                page: leaf,\n                //@ts-expect-error\n                scope: leaf.root.scope,\n              })\n            }\n            if (visible) {\n              let curLeaf: Leaf | null = leaf.parent\n              while (curLeaf) {\n                if (\n                  curLeaf.data.type === 'route' &&\n                  !curLeaf.data.block.visible\n                ) {\n                  // listData.pendingUpdate = input\n                  return\n                }\n                curLeaf = curLeaf.parent\n              }\n            }\n            changeChildLeafsVisible(visible, leaf)\n          })\n        },\n      })\n      setInParentIndex(routeItemTemplate)\n      const {onMount, onState: onVisibleChange} = mutualSample({\n        mount,\n        state,\n        onMount: ({visible, value}, leaf) => ({\n          leaf,\n          visible,\n          value,\n        }),\n        onState: (leaf, {visible, value}) => ({\n          leaf,\n          visible,\n          value,\n        }),\n      })\n      const pendingInit = createEvent<T>()\n      const pendingInitWithData = sample({\n        source: mount,\n        clock: pendingInit,\n        greedy: true,\n        fn: (leaf, value) => ({leaf, value, visible: true}),\n      })\n      merge([onMount, onVisibleChange, pendingInitWithData]).watch(\n        ({leaf, visible, value}) => {\n          const data = leaf.data as LeafDataRoute\n          data.block.visible = visible\n          /** stop pending route initialization if route become invisible */\n          if (!visible && !data.initialized && data.pendingInit) {\n            data.pendingInit = null\n            return\n          }\n          if (visible && !data.initialized) {\n            let curLeaf: Leaf | null = leaf.parent\n            while (curLeaf) {\n              if (\n                curLeaf.data.type === 'route' &&\n                !curLeaf.data.block.visible\n              ) {\n                data.pendingInit = {value}\n                return\n              }\n              curLeaf = curLeaf.parent\n            }\n          }\n          if (visible && !data.initialized) {\n            mountChild({\n              parentBlockFragment: data.block,\n              leaf,\n              actor: routeItemTemplate,\n              values: {store: value},\n            })\n            data.initialized = true\n          }\n        },\n      )\n      return {pendingInit}\n    },\n  })\n  setInParentIndex(routeTemplate)\n}\n","import {Store, launch, createEvent} from 'effector'\n\nimport type {RecItemDraft, LeafDataRecItem, RecDraft} from '../index.h'\n\nimport {createTemplate, currentTemplate} from '../template'\nimport {mountChild, setInParentIndex} from '../mountChild'\nimport {iterateChildLeafs} from '../iterateChildLeafs'\nimport {assertClosure} from '../assert'\nimport {mountFn} from '../mountFn'\nimport {mutualSample} from '../mutualSample'\n\nexport function rec<T>(config: {\n  fn(config: {store: Store<T>}): void\n}): (opts: {store: Store<T>}) => void\nexport function rec<T>(\n  fn: (config: {store: Store<T>; state?: Store<T>}) => void,\n): (opts: {store: Store<T>; state?: Store<T>}) => void\nexport function rec<T>(\n  fnOrConfig:\n    | {\n        fn(config: {store: Store<T>}): void\n      }\n    | ((config: {store: Store<T>; state?: Store<T>}) => void),\n): (opts: {store: Store<T>; state?: Store<T>}) => void {\n  const fn = typeof fnOrConfig === 'function' ? fnOrConfig : fnOrConfig.fn\n  const recDraft: RecDraft = {\n    type: 'rec',\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: 0,\n  }\n  const recTemplate = createTemplate<{\n    itemUpdater: any\n  }>({\n    name: 'rec',\n    state: {store: null},\n    isSvgRoot: false,\n    //@ts-expect-error\n    namespace: null,\n    //@ts-expect-error\n    env: null,\n    draft: recDraft,\n    defer: true,\n    isBlock: true,\n    fn({store}, {mount}) {\n      fn({store, state: store})\n      //@ts-expect-error\n      const itemUpdater = createEvent<any>({named: 'itemUpdater'})\n      store.on(itemUpdater, (_, e) => e)\n      mount.watch(mountFn.rec)\n      return {itemUpdater}\n    },\n  })\n  return ({store, state = store}) => {\n    assertClosure(currentTemplate, '(rec instance)')\n    const {env, namespace} = currentTemplate\n    if (recTemplate.deferredInit) recTemplate.deferredInit()\n\n    const recItemDraft: RecItemDraft = {\n      type: 'recItem',\n      childTemplates: [],\n      childCount: 0,\n      inParentIndex: -1,\n    }\n    const recItemTemplate = createTemplate({\n      name: 'rec item',\n      isSvgRoot: false,\n      namespace,\n      env,\n      draft: recItemDraft,\n      fn(_, {mount}) {\n        const {onMount, onState} = mutualSample({\n          state,\n          mount,\n          onMount: (state, leaf) => ({state, leaf}),\n          onState: (leaf, state) => ({state, leaf}),\n        })\n        onState.watch(({state, leaf}) => {\n          iterateChildLeafs(leaf, child => {\n            launch({\n              target: child.template.api.itemUpdater,\n              params: state,\n              defer: true,\n              page: leaf,\n              //@ts-expect-error\n              scope: leaf.root.scope,\n            })\n          })\n        })\n        onMount.watch(({leaf, state}) => {\n          const data = leaf.data as LeafDataRecItem\n          mountChild({\n            parentBlockFragment: data.block,\n            leaf,\n            actor: recTemplate,\n            values: {store: state},\n          })\n        })\n      },\n    })\n    setInParentIndex(recItemTemplate)\n  }\n}\n","import type {StoreOrData, DOMProperty} from './index.h'\n\nexport type Word =\n  | StoreOrData<DOMProperty>\n  | StoreOrData<string>\n  | StoreOrData<number>\n\nexport function createWordsArray(\n  x: TemplateStringsArray,\n  args: Array<Word>,\n): Array<Word> {\n  if (args.length === 0) return x as any\n  const words: Array<Word> = [x[0]]\n  for (let i = 0; i < args.length; i++) {\n    words.push(args[i], x[i + 1])\n  }\n  return words\n}\n","export const USE_PERF = true\n\nexport const TASK_DEADLINE = 1000\n","export let now: () => number\n\nif (typeof performance !== 'undefined' && performance.now) {\n  now = () => performance.now()\n} else if (typeof process !== 'undefined' && process.hrtime) {\n  now = () => {\n    const hr = process.hrtime()\n    return (hr[0] * 1e9 + hr[1]) / 1e6\n  }\n} else {\n  now = () => Date.now()\n}\n","import {USE_PERF} from './env'\nimport {now} from './now'\ntype Bucket = {\n  calls: number\n  time: number\n  label: string\n  childTime: number\n}\nexport const measures = new Map<string, Bucket>()\nconst bucketStack: Array<{bucket: Bucket; pendingStart: number}> = []\nconst startMeasure = (label: string) => {\n  let bucket = measures.get(label)\n  if (!bucket) {\n    bucket = {\n      calls: 0,\n      time: 0,\n      label,\n      childTime: 0,\n    }\n    measures.set(label, bucket)\n  }\n  bucket.calls += 1\n  bucketStack.push({bucket, pendingStart: now()})\n}\nconst endMeasure = (label: string) => {\n  const bucket = measures.get(label)!\n  const pendingStart = bucketStack.pop()!.pendingStart\n  const time = now() - pendingStart\n  bucket.time += time\n\n  if (bucketStack.length > 0) {\n    const parent = bucketStack[bucketStack.length - 1].bucket\n    parent.childTime += time\n  }\n}\n\nexport {startMeasure as perfStart, endMeasure as perfEnd}\n\nexport let beginMark: (label: string) => void\nexport let endMark: (label: string) => void\nif (USE_PERF && typeof performance !== 'undefined' && performance.mark) {\n  beginMark = label => {\n    performance.mark('☄️ ' + label + ' start')\n    startMeasure(label)\n  }\n  endMark = label => {\n    endMeasure(label)\n    try {\n      performance.measure('☄️ ' + label, '☄️ ' + label + ' start')\n    } catch (err) {} // Clear marks immediately to avoid growing buffer.\n\n    performance.clearMarks('☄️ ' + label + ' start')\n    performance.clearMeasures('☄️ ' + label)\n  }\n} else {\n  beginMark = label => {\n    startMeasure(label)\n  }\n  endMark = label => {\n    endMeasure(label)\n  }\n}\n","export const raf =\n  typeof requestAnimationFrame !== 'undefined'\n    ? requestAnimationFrame\n    : (cb: Function) => setTimeout(cb, 0)\n\nexport const cancelRaf: (id: number | NodeJS.Timeout) => void =\n  typeof cancelAnimationFrame !== 'undefined'\n    ? cancelAnimationFrame\n    : clearTimeout\n","import type {StateRef, StateRefOp, Node, Cmd} from '../effector/index.h'\nimport type {TemplateHandlers, Template} from './index.h'\n\nconst addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  ref.before!.push(op as any)\n}\n\nconst includes = <T>(arr: T[], value: T) => arr.includes(value)\n\nexport const handlers: TemplateHandlers = {\n  storeBase(template: Template, plainState: StateRef) {\n    template.plain.push(plainState)\n  },\n  storeOnMap(\n    template: Template,\n    plainState: StateRef,\n    seq: (Cmd | void)[],\n    fromRef: StateRef | false,\n  ) {\n    seq.unshift(template.loader)\n    seq.push(template.upward)\n    if (fromRef) {\n      if (!includes(template.plain, fromRef)) {\n        //if (!includes(seq, template.loader)) {\n        //  seq.unshift(template.loader)\n        //}\n        if (!includes(template.closure, fromRef)) {\n          template.closure.push(fromRef)\n        }\n        addRefOp(plainState, {\n          type: 'closure',\n          of: fromRef,\n        })\n      }\n    } else {\n      //if (!includes(seq, template.loader)) {\n      //  seq.unshift(template.loader)\n      //}\n    }\n  },\n  storeMap(template: Template, plainState: StateRef, linkNode: Node) {\n    if (\n      !includes(template.plain, plainState) &&\n      !includes(linkNode.seq, template.loader)\n    ) {\n      linkNode.seq.unshift(template.loader)\n    }\n  },\n  storeWatch(\n    template: Template,\n    plainState: StateRef,\n    fn: (value: unknown) => unknown,\n  ) {\n    template.watch.push({of: plainState, fn})\n    return true\n  },\n  eventPrepend(template: Template, contramapped: Node) {\n    contramapped.seq.push(template.upward)\n  },\n  combineBase(template: Template, rawShape: StateRef, isFresh: StateRef) {\n    template.plain.push(rawShape, isFresh)\n  },\n  combineField(template: Template, childRef: StateRef, linkNode: Node) {\n    if (!includes(template.plain, childRef)) {\n      linkNode.seq.unshift(template.loader)\n    }\n  },\n  splitBase(template: Template, lastValues: StateRef) {\n    template.plain.push(lastValues)\n  },\n  splitMatchStore(template: Template, storeRef: StateRef, linkNode: Node) {\n    if (!includes(template.plain, storeRef)) {\n      linkNode.seq.unshift(template.loader)\n    }\n  },\n  sampleStoreSource(template: Template, sourceRef: StateRef) {\n    if (\n      !includes(template.plain, sourceRef) &&\n      !includes(template.closure, sourceRef)\n    ) {\n      template.closure.push(sourceRef)\n    }\n  },\n  sampleNonStoreSource(\n    template: Template,\n    hasSource: StateRef,\n    sourceRef: StateRef,\n    clockState: StateRef,\n  ) {\n    template.plain.push(hasSource, sourceRef, clockState)\n  },\n  sampleTarget(template: Template, target: Node) {\n    target.seq.push(template.loader)\n  },\n  sampleSourceLoader: (template: Template) => template.loader,\n  sampleSourceUpward: (template: Template, isUpward: boolean) =>\n    isUpward && template.upward,\n}\n","import type {\n  Leaf,\n  LeafDataRoute,\n  RouteDraft,\n  RecDraft,\n  LeafDataRec,\n  BlockDraft,\n  BlockItemDraft,\n  LeafDataBlock,\n  LeafDataBlockItem,\n  LeafDataUsing,\n  LeafDataListItem,\n} from './index.h'\n\nimport {mountChild, mountChildTemplates} from './mountChild'\n\nexport const mountFn = {\n  using(leaf: Leaf) {\n    const data = leaf.data as LeafDataUsing\n    const block = data.block\n    mountChildTemplates(data.draft, {\n      parentBlockFragment: block,\n      leaf,\n    })\n  },\n  routeItem(leaf: Leaf) {\n    const draft = leaf.draft as RouteDraft\n    const data = leaf.data as LeafDataRoute\n    data.block.visible = true\n    mountChildTemplates(draft, {\n      parentBlockFragment: data.block,\n      leaf,\n    })\n  },\n  block(leaf: Leaf) {\n    const draft = leaf.draft as BlockDraft\n    const data = leaf.data as LeafDataBlock\n    mountChildTemplates(draft, {\n      parentBlockFragment: data.block,\n      leaf,\n    })\n  },\n  blockItem(leaf: Leaf) {\n    const draft = leaf.draft as BlockItemDraft\n    const data = leaf.data as LeafDataBlockItem\n    mountChild({\n      parentBlockFragment: data.block,\n      leaf,\n      actor: draft.itemOf,\n    })\n  },\n  rec(leaf: Leaf) {\n    const draft = leaf.draft as RecDraft\n    const data = leaf.data as LeafDataRec\n    mountChildTemplates(draft, {\n      parentBlockFragment: data.block,\n      leaf,\n    })\n  },\n  listItem(leaf: Leaf) {\n    const data = leaf.data as LeafDataListItem\n    const block = data.block\n    block.visible = true\n    block.childInitialized = true\n    mountChildTemplates(data.listDraft, {\n      parentBlockFragment: block,\n      leaf,\n    })\n  },\n}\n","import type {NSType, BlockDraft, BlockItemDraft} from '../index.h'\n\nimport {createTemplate, currentTemplate} from '../template'\nimport {assertClosure} from '../assert'\nimport {mountFn} from '../mountFn'\nimport {setInParentIndex} from '../mountChild'\n\nexport function block({\n  fn,\n  env,\n  namespace = 'html',\n}: {\n  fn: () => void\n  env: any\n  namespace?: NSType\n}): () => void {\n  const blockDraft: BlockDraft = {\n    type: 'block',\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: 0,\n  }\n  const blockTemplate = createTemplate({\n    name: 'block',\n    isSvgRoot: false,\n    namespace,\n    env,\n    draft: blockDraft,\n    isBlock: true,\n    fn({}, {mount}) {\n      fn()\n      mount.watch(mountFn.block)\n    },\n  })\n  return () => {\n    assertClosure(currentTemplate, '(block instance)')\n    const blockItemDraft: BlockItemDraft = {\n      type: 'blockItem',\n      childTemplates: [],\n      childCount: 0,\n      inParentIndex: -1,\n      itemOf: blockTemplate,\n    }\n    const {env, namespace} = currentTemplate\n    const blockItemTemplate = createTemplate({\n      name: 'block item',\n      isSvgRoot: false,\n      namespace,\n      env,\n      draft: blockItemDraft,\n      fn(_, {mount}) {\n        mount.watch(mountFn.blockItem)\n      },\n    })\n    setInParentIndex(blockItemTemplate)\n  }\n}\n","import type {DOMElement} from '../index.h'\n\nimport {currentTemplate} from '../template'\n\nimport {assertClosure} from '../assert'\n\nexport function node(cb: (node: DOMElement) => (() => void) | void) {\n  assertClosure(currentTemplate, 'node')\n  const draft = currentTemplate.draft\n  switch (draft.type) {\n    case 'list':\n    case 'listItem':\n    case 'using':\n    case 'route':\n    case 'rec':\n    case 'recItem':\n    case 'block':\n    case 'blockItem':\n      console.error('node() hook supported only in h() nodes')\n      return\n  }\n  draft.node.push(cb)\n}\n","import {spec} from './spec'\nimport {Word, createWordsArray} from '../wordsArray'\n\nexport function text(x: TemplateStringsArray, ...args: Array<Word>) {\n  if (Array.isArray(x)) {\n    spec({text: createWordsArray(x, args) as any})\n  } else {\n    spec({text: x as any})\n  }\n}\n","import type {Store} from 'effector'\n\nimport {rec} from './rec'\nimport {list} from './list'\n\nexport function tree<\n  T,\n  ChildField extends keyof T,\n  // KeyField extends keyof T\n>(config: {\n  source: Store<T[]>\n  // key: T[KeyField] extends string ? KeyField : never\n  child: T[ChildField] extends T[] ? ChildField : never\n  fn: (config: {store: Store<T>; child: () => void}) => void\n}): void\nexport function tree({\n  source,\n  key,\n  child: childField,\n  fn,\n}: {\n  source: Store<any[]>\n  key?: string\n  child: string\n  fn: Function\n}) {\n  const treeRec = rec<any[]>(({store}) => {\n    list({\n      source: store,\n      key: key!,\n      fn({store}) {\n        const childList = store.map(value => value[childField] || [])\n        fn({\n          store,\n          child() {\n            treeRec({\n              store: childList,\n            })\n          },\n        })\n      },\n    })\n  })\n  treeRec({\n    store: source,\n  })\n}\n","import {combine, is} from 'effector'\nimport {Word, createWordsArray} from '../wordsArray'\n\nexport function val(x: TemplateStringsArray, ...args: Array<Word>) {\n  if (args.every(arg => !is.store(arg)))\n    return createWordsArray(x, args).join('')\n  return combine(args, args => createWordsArray(x, args).join(''))\n}\n","import {Store, is} from 'effector'\n\nimport {currentTemplate} from '../template'\nimport {assert, assertClosure} from '../assert'\n\nimport {route} from './route'\n\nexport function variant<T, K extends keyof T>({\n  source,\n  cases,\n  key,\n}: {\n  source: Store<T>\n  key: K\n  cases: T[K] extends string\n    ? Record<T[K], (config: {store: Store<T>}) => void>\n    : {\n        [caseName: string]: (config: {store: Store<T>}) => void\n        __: (config: {store: Store<T>}) => void\n      }\n}) {\n  assertClosure(currentTemplate, 'variant')\n  assert(is.unit(source), 'variant({source}) should be unit')\n  let keyReader: (value: any) => any\n\n  if (typeof key === 'function') keyReader = key\n  else if (key == null) keyReader = (value: any) => String(value)\n  else keyReader = (value: any) => String(value[key])\n\n  let defaultCase = false\n\n  for (const caseName in cases) {\n    if (caseName === '__') {\n      defaultCase = true\n      continue\n    }\n    route({\n      source,\n      visible: value => keyReader(value) === caseName,\n      fn: cases[caseName],\n    })\n  }\n  if (defaultCase) {\n    const nonDefaultCases = Object.keys(cases)\n    route({\n      source,\n      visible: value => !nonDefaultCases.includes(keyReader(value)),\n      //@ts-expect-error\n      fn: cases.__,\n    })\n  }\n}\n"],"names":["removeOpGroupFromQueue","group","priority","cursor","prev","next","queue","last","first","removeOpFromQueue","op","status","item","removeItemFromQueue","getOpQueue","activeChilds","forceSetOpValue","value","active","pending","pushOpToQueue","addOpGroupToQueue","addItemToQueue","rafID","raf","execQueue","beginMark","start","now","interrupted","quant","props","tree","data","TASK_DEADLINE","hasPropsTasks","endMark","runOp","hasTreeTasks","hasDataTasks","onDrain","rs","createOp","createOpQueue","onComplete","bind","createOpGroup","ops","createAsyncValue","onInit","onChange","change","init","terminate","stopAsyncValue","updateAsyncValue","escapeTag","String","replace","applyStaticOps","element","defs","i","length","type","field","defMap","isFalse","val","applyStyleVar","style","removeProperty","setProperty","applyStyle","applyDataAttr","dataset","applyAttr","checked","setAttribute","removeAttribute","applyText","textNode","text","replaceData","textContent","createTemplate","fn","state","values","defer","name","draft","isSvgRoot","namespace","env","isBlock","parent","currentTemplate","template","id","templateID","plain","watch","nameMap","pages","closure","childTemplates","handlers","upward","step","filter","upd","scope","stack","page","root","activeSpawns","has","fullID","console","count","stackTemplates","stackPages","currentStackPage","push","node","forEach","targetTemplate","meta","nativeTemplate","includes","indexOf","launch","target","params","error","loader","forkId","graphite","childSpawns","isRecTemplate","startsWith","validTarget","recID","parentPage","api","trigger","mount","createEvent","named","createNode","deferredInit","prevTemplate","withRegion","restore","getCurrent","ref","forkPage","result","getState","current","findRef","targetLeaf","currentLeaf","regRef","reg","findRefValue","ensureLeafHasRef","leaf","addMapItems","record","spawn","parentLeaf","mountNode","svgRoot","leafData","opGroup","domSubtree","hydration","execRef","before","cmd","from","of","runWatchersFrom","list","stop","err","spawnID","previousSpawn","add","leafOps","closureRef","findClosure","stateRef","mountQueue","steps","shift","findParentDOMElement","block","findLastVisibleChildBlock","visible","child","visibleChild","lastChild","left","findPreviousVisibleSiblingBlock","sibling","parentFragment","index","findPreviousVisibleSibling","assert","condition","msg","Error","assertClosure","currentActor","methodName","setInParentIndex","inParentIndex","childCount","warn","mountChildTemplates","parentBlockFragment","actor","mountChild","fragmentParentTypes","parentDomSubtree","routeBlock","initialized","pendingInit","tag","document","createElementNS","createElement","staticSeq","stencil","cloneNode","elementBlock","appendChild","leafData_","needToCallNode","onMount","fns","childSpawn","remove","listBlock","records","pendingUpdate","recBlock","recItemBlock","visibleSibling","after","prepend","mutualSample","onState","sample","source","clock","greedy","forIn","obj","cb","key","handler","options","map","undefined","is","unit","passive","capture","prevent","domConfig","spec","config","itemVisible","attr","firstIndex","Array","isArray","escaped","styleVar","handlerDef","on","ɔ","createPropsOp","initCtx","hooks","opID","opsAmount","ctx","propertyMapToOpDef","slice","installTextNode","childIndex","parentBlock","textBlock","siblingBlock","createTextNode","nextSibling","parentElement","firstChild","processStoreRef","store","templ","getDefaultEnv","iterateChildLeafs","childs","changeChildLeafsVisible","childLeafIterator","update","log","unmountChildLeafsNoEvent","delete","unmountLeafTree","unmountOwnSpawn","removeItem","halt","instance","listItemBlock","leftBlock","rightBlock","right","splice","remap","shape","projectedKey","opts","maybeFn","fields","getID","_","listItemTemplate","itemUpdater","e","mountAndVisible","onVisibleChanges","childInitialized","mountFn","listItem","updates","createStore","mappedUpdates","x","mountData","parentNodeUpdateSpawn","input","listData","curLeaf","shortName","skipNode","fill","keys","resultRecords","asyncValue","listDraft","leftSibling","route","routeTemplate","combine","visibleFn","routeItemTemplate","onValueUpdate","routeItem","onVisibleChange","pendingInitWithData","merge","rec","fnOrConfig","recTemplate","createWordsArray","args","words","performance","process","hrtime","hr","Date","measures","Map","bucketStack","startMeasure","label","bucket","get","calls","time","childTime","set","pendingStart","endMeasure","pop","mark","measure","clearMarks","clearMeasures","requestAnimationFrame","setTimeout","arr","storeBase","plainState","storeOnMap","seq","fromRef","unshift","addRefOp","storeMap","linkNode","storeWatch","eventPrepend","contramapped","combineBase","rawShape","isFresh","combineField","childRef","splitBase","lastValues","splitMatchStore","storeRef","sampleStoreSource","sourceRef","sampleNonStoreSource","hasSource","clockState","sampleTarget","sampleSourceLoader","sampleSourceUpward","isUpward","syncOperations","propertyOperationBinding","readElement","using","blockItem","itemOf","blockTemplate","blockItemDraft","hasCb","hasOpts","parentNS","ns","xmlns","elementTemplate","domElementCreated","opsMap","for","foundElement","nodeName","emptyText","onMountSync","immediate","some","handlerTemplate","handlerPageFound","currentPage","addEventListener","preventDefault","stopPropagation","visibleOp","childField","treeRec","childList","hydrate","onRoot","Set","namespaceURI","tagName","toLowerCase","usingTemplate","usingBlock","rootLeaf","every","arg","join","cases","keyReader","defaultCase","caseName","nonDefaultCases","Object","__"],"mappings":"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"}