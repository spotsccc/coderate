{"version":3,"file":"patronum.cjs.js","sources":["library.js","combine-events/index.js","condition/index.js","debounce/index.js","debug/index.js","delay/index.js","every/index.js","in-flight/index.js","pending/index.js","reshape/index.js","some/index.js","split-map/index.js","spread/index.js","status/index.js","throttle/index.js","index.js"],"sourcesContent":["/* eslint-disable no-param-reassign */\n\nfunction readProperties(part, target, properties) {\n  properties\n    .filter((name) => typeof part[name] !== 'undefined')\n    .forEach((name) => {\n      target[name] = part[name];\n    });\n}\n\nconst readConfig = (part, properties, target = {}) => {\n  if (typeof part !== 'object' || part === null) return target;\n\n  if (part.config) readConfig(part.config, properties, target);\n\n  readProperties(part, target, properties);\n\n  if (part.ɔ) readConfig(part.ɔ, properties, target);\n\n  return target;\n};\n\nmodule.exports = { readConfig };\n","const {\n  createStore,\n  createEvent,\n  guard,\n  merge,\n  sample,\n  withRegion,\n  is,\n} = require('effector');\nconst { readConfig } = require('../library');\n\nconst throwError = (message) => {\n  throw new Error(message);\n};\n\nfunction combineEvents(argument) {\n  const {\n    loc,\n    name = 'unknown',\n    events,\n    reset,\n    target: givenTarget,\n  } = readConfig(argument, ['loc', 'name', 'events', 'reset', 'target']);\n\n  const target = givenTarget || createEvent({ name });\n\n  if (!is.unit(target)) throwError('target should be a unit');\n  if (reset && !is.unit(reset)) throwError('reset should be a unit');\n\n  withRegion(target, () => {\n    const isArray = Array.isArray(events);\n    const keys = Object.keys(events);\n    const defaultShape = isArray ? [...keys].fill() : {};\n\n    const $counter = createStore(keys.length, { name: `${name}Counter`, loc });\n    const $results = createStore(defaultShape, {\n      name: `${name}Results`,\n      loc,\n    });\n\n    $counter.reset(sample(target));\n    $results.reset(target);\n\n    if (reset) {\n      $counter.reset(sample(reset));\n      $results.reset(reset);\n    }\n\n    for (const key of keys) {\n      const $isDone = createStore(false)\n        .on(events[key], () => true)\n        .reset(target);\n\n      if (reset) {\n        $isDone.reset(reset);\n      }\n\n      $counter.on($isDone, (value) => value - 1);\n      $results.on(events[key], (shape, payload) => {\n        const newShape = isArray ? [...shape] : { ...shape };\n        newShape[key] = payload;\n        return newShape;\n      });\n    }\n\n    guard({\n      source: sample($results, merge(Object.values(events))),\n      filter: $counter.map((value) => value === 0),\n      target,\n    });\n  });\n\n  return target;\n}\n\nmodule.exports = { combineEvents };\n","const { is, guard, createEvent } = require('effector');\nconst { readConfig } = require('../library');\n\n/**\n * if — (payload: T) => boolean,\n * if — Store<boolean>\n * if — T\n */\nfunction condition(argument) {\n  const {\n    name = 'unknown',\n    source = createEvent({ name: `${name}Source` }),\n    if: test,\n    then: thenBranch,\n    else: elseBranch,\n  } = readConfig(argument, ['name', 'source', 'if', 'then', 'else']);\n\n  const checker =\n    is.unit(test) || isFunction(test) ? test : (value) => value === test;\n\n  if (thenBranch) {\n    guard({\n      source,\n      filter: checker,\n      target: thenBranch,\n    });\n  }\n\n  if (elseBranch) {\n    guard({\n      source,\n      filter: inverse(checker),\n      target: elseBranch,\n    });\n  }\n\n  return source;\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nfunction inverse(fnOrUnit) {\n  if (is.unit(fnOrUnit)) {\n    return fnOrUnit.map((value) => !value);\n  }\n  return (value) => !fnOrUnit(value);\n}\n\nmodule.exports = { condition };\n","const { is, createEffect, forward, createEvent } = require('effector');\nconst { readConfig } = require('../library');\n\nfunction debounce(argument) {\n  const { source, timeout, target, sid, loc, name } = readConfig(argument, [\n    'source',\n    'timeout',\n    'target',\n\n    'loc',\n    'name',\n    'sid',\n  ]);\n\n  if (!is.unit(source))\n    throw new TypeError('source must be unit from effector');\n  if (is.domain(source)) throw new TypeError('source cannot be domain');\n\n  if (typeof timeout !== 'number' || timeout < 0 || !Number.isFinite(timeout))\n    throw new Error(\n      `timeout must be positive number or zero. Received: \"${timeout}\"`,\n    );\n\n  const actualName = name || source.shortName || 'unknown';\n\n  let rejectPromise;\n  let timeoutId;\n\n  const tick =\n    target ||\n    createEvent({\n      name: `${actualName}DebounceTick`,\n      loc,\n    });\n\n  const timerFx = createEffect({\n    name: `${actualName}DebounceTimer`,\n    sid,\n    loc,\n    handler: (parameter) => {\n      clearTimeout(timeoutId);\n      if (rejectPromise) rejectPromise();\n      return new Promise((resolve, reject) => {\n        rejectPromise = reject;\n        timeoutId = setTimeout(resolve, timeout, parameter);\n      });\n    },\n  });\n\n  forward({\n    from: source,\n    to: timerFx,\n  });\n\n  forward({\n    from: timerFx.done.map(({ result }) => result),\n    to: tick,\n  });\n\n  return tick;\n}\n\nmodule.exports = { debounce };\n","/* eslint-disable no-console, prefer-template */\nconst { is } = require('effector');\n\nfunction debug() {\n  const units = Array.from(arguments);\n\n  for (const unit of units) {\n    const type = getType(unit);\n\n    if (unit.watch) {\n      log(unit, type);\n    }\n\n    if (type === 'effect') {\n      logEffect(unit);\n    }\n\n    if (type === 'domain') {\n      unit.onCreateEvent((event) => log(event, 'event'));\n      unit.onCreateStore((store) => log(store, 'store'));\n      unit.onCreateEffect(logEffect);\n    }\n  }\n}\n\nfunction getType(unit) {\n  if (is.store(unit)) {\n    return 'store';\n  }\n  if (is.effect(unit)) {\n    return 'effect';\n  }\n  if (is.event(unit)) {\n    return 'event';\n  }\n  if (is.domain(unit)) {\n    return 'domain';\n  }\n  if (is.unit(unit)) {\n    return 'unit';\n  }\n  return 'unknown';\n}\n\nfunction log(unit, type, prefix = '') {\n  const name = prefix + getName(unit);\n\n  unit.watch((payload) => {\n    console.info(`[${type}] ${name}`, payload);\n  });\n}\n\nfunction logEffect(unit) {\n  log(unit.done, 'effect', getName(unit) + '.');\n  log(unit.fail, 'effect', getName(unit) + '.');\n}\n\nfunction getName(unit) {\n  if (unit.compositeName && unit.compositeName.fullName) {\n    return unit.compositeName.fullName;\n  }\n  if (unit.shortName) {\n    return unit.shortName;\n  }\n  if (unit.name) {\n    return unit.name;\n  }\n  return '';\n}\n\nmodule.exports = { debug };\n","const { createEffect, createEvent, forward, is, sample } = require('effector');\nconst { readConfig } = require('../library');\n\nfunction delay(argument) {\n  const {\n    loc,\n    name = 'unknown',\n    sid,\n\n    source,\n    timeout,\n    target = createEvent({ name: `${name}Delayed`, sid, loc }),\n  } = readConfig(argument, [\n    'loc',\n    'sid',\n    'name',\n\n    'source',\n    'timeout',\n    'target',\n  ]);\n\n  if (!is.unit(source))\n    throw new TypeError('source must be a unit from effector');\n\n  if (!is.unit(target))\n    throw new TypeError('target must be a unit from effector');\n\n  const ms = validateTimeout(timeout);\n\n  const timerFx = createEffect({\n    config: { name: `${name}DelayTimer`, loc },\n    handler: ({ payload, milliseconds }) =>\n      new Promise((resolve) => {\n        setTimeout(resolve, milliseconds, payload);\n      }),\n  });\n\n  sample({\n    // ms can be Store<number> | number\n    // sample calls combine() on source to convert object of stores or object of values to store\n    source: { milliseconds: ms },\n    clock: source,\n    fn: ({ milliseconds }, payload) => ({\n      payload,\n      milliseconds:\n        typeof milliseconds === 'function'\n          ? milliseconds(payload)\n          : milliseconds,\n    }),\n    target: timerFx,\n  });\n\n  forward({\n    from: timerFx.doneData,\n    to: target,\n  });\n\n  return target;\n}\n\nmodule.exports = { delay };\n\nfunction validateTimeout(timeout) {\n  if (\n    is.store(timeout) ||\n    typeof timeout === 'function' ||\n    typeof timeout === 'number'\n  ) {\n    return timeout;\n  }\n\n  throw new TypeError(\n    `'timeout' argument must be a function, Store, or a number. Passed \"${typeof timeout}\"`,\n  );\n}\n","const { combine } = require('effector');\nconst { readConfig } = require('../library');\n\nfunction every(argument) {\n  const { predicate, stores } = readConfig(argument, ['predicate', 'stores']);\n\n  const checker = isFunction(predicate)\n    ? predicate\n    : (value) => value === predicate;\n\n  return combine(stores, (values) => values.every(checker));\n}\n\nmodule.exports = { every };\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n","const { combine } = require('effector');\nconst { readConfig } = require('../library');\n\nfunction inFlight(argument) {\n  const { effects, domain, sid, name, loc } = readConfig(argument, [\n    'effects',\n    'domain',\n\n    'sid',\n    'name',\n    'loc',\n  ]);\n\n  if (domain) {\n    const $inFlight = domain.createStore(0, { sid, name, loc });\n\n    domain.onCreateEffect((fx) => {\n      $inFlight\n        .on(fx, (count) => count + 1)\n        .on(fx.finally, (count) => count - 1);\n    });\n\n    return $inFlight;\n  }\n\n  return combine(\n    effects.map((fx) => fx.inFlight),\n    (inFlights) => inFlights.reduce((all, current) => all + current, 0),\n  );\n}\n\nmodule.exports = { inFlight };\n","const { combine, is } = require('effector');\nconst { readConfig } = require('../library');\n\nconst strategies = {\n  some: (list) => list.some(Boolean),\n  every: (list) => list.every(Boolean),\n};\n\nfunction pending(argument) {\n  const { effects: rawEffects, domain, of = 'some' } = readConfig(argument, [\n    'effects',\n    'domain',\n    'of',\n  ]);\n\n  if (!is.domain(domain) && !rawEffects)\n    throw new TypeError('domain or effects should be passed');\n\n  if (of !== 'some' && of !== 'every')\n    throw new TypeError(\n      `strategy parameter \"of\" can be \"every\" or \"some\". Passed: \"${of}\"`,\n    );\n\n  let effects = rawEffects;\n  const strategy = strategies[of];\n\n  if (domain) {\n    effects = [];\n    domain.onCreateEffect((fx) => effects.push(fx));\n  }\n\n  return combine(\n    effects.map((fx) => fx.pending),\n    strategy,\n  );\n}\n\nmodule.exports = { pending };\n","const { readConfig } = require('../library');\n\nfunction reshape(argument) {\n  const { source, shape } = readConfig(argument, ['source', 'shape']);\n  const result = {};\n\n  for (const key in shape) {\n    if (key in shape) {\n      const fn = shape[key];\n      result[key] = source.map((state) => {\n        const result = fn(state);\n        return result === undefined ? null : result;\n      });\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = { reshape };\n","const { combine } = require('effector');\nconst { readConfig } = require('../library');\n\nfunction some(argument) {\n  const { predicate, stores } = readConfig(argument, ['predicate', 'stores']);\n\n  const checker = isFunction(predicate)\n    ? predicate\n    : (value) => value === predicate;\n\n  return combine(stores, (values) => values.some(checker));\n}\n\nmodule.exports = { some };\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n","const { is } = require('effector');\nconst { readConfig } = require('../library');\n\nfunction splitMap(argument) {\n  const { source, cases } = readConfig(argument, ['source', 'cases']);\n  const result = {};\n\n  let current = is.store(source) ? source.updates : source;\n\n  for (const key in cases) {\n    if (key in cases) {\n      const fn = cases[key];\n\n      result[key] = current.filterMap(fn);\n      current = current.filter({\n        fn: (data) => !fn(data),\n      });\n    }\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  result.__ = current;\n\n  return result;\n}\n\nmodule.exports = { splitMap };\n","/* eslint-disable no-param-reassign */\nconst { createEvent, sample, guard } = require('effector');\nconst { readConfig } = require('../library');\n\n/**\n * @example\n * spread({ source: dataObject, targets: { first: targetA, second: targetB } })\n * forward({\n *   to: spread({targets: { first: targetA, second: targetB } })\n * })\n */\nfunction spread(argument) {\n  const {\n    loc,\n    name = 'unknown',\n    source = createEvent({ loc, name: `${name}Source` }),\n    targets,\n  } = readConfig(argument, ['loc', 'name', 'source', 'targets']);\n\n  for (const targetKey in targets) {\n    if (targetKey in targets) {\n      const hasTargetKey = guard({\n        source,\n        filter: (object) =>\n          typeof object === 'object' && object !== null && targetKey in object,\n      });\n\n      sample({\n        source: hasTargetKey,\n        fn: (object) => object[targetKey],\n        target: targets[targetKey],\n      });\n    }\n  }\n\n  return source;\n}\n\nmodule.exports = { spread };\n","const { createStore } = require('effector');\nconst { readConfig } = require('../library');\n\nfunction status(argument) {\n  const {\n    sid,\n    name,\n    loc,\n    effect,\n    defaultValue = 'initial',\n  } = readConfig(argument, ['sid', 'name', 'loc', 'effect', 'defaultValue']);\n  const $status = createStore(defaultValue, { sid, loc, name });\n\n  $status\n    .on(effect, () => 'pending')\n    .on(effect.done, () => 'done')\n    .on(effect.fail, () => 'fail');\n\n  return $status;\n}\n\nmodule.exports = { status };\n","const { createEffect, createEvent, guard, is, sample } = require('effector');\nconst { readConfig } = require('../library');\n\nfunction throttle(argument) {\n  const { source, timeout, target, sid, loc, name } = readConfig(argument, [\n    'source',\n    'timeout',\n    'target',\n\n    'loc',\n    'name',\n    'sid',\n  ]);\n\n  if (!is.unit(source))\n    throw new TypeError('source must be unit from effector');\n  if (typeof timeout !== 'number' || timeout < 0)\n    throw new Error('timeout must be positive number or zero');\n\n  const actualName = name || source.shortName || 'unknown';\n\n  const tick =\n    target ||\n    createEvent({\n      name: `${actualName}ThrottleTick`,\n      loc,\n    });\n\n  const timerFx = createEffect({\n    name: `${actualName}ThrottleTimer`,\n    sid,\n    loc,\n    handler: () => new Promise((resolve) => setTimeout(resolve, timeout)),\n  });\n\n  guard({\n    source,\n    filter: timerFx.pending.map((pending) => !pending),\n    target: timerFx,\n  });\n\n  sample({\n    source,\n    clock: timerFx.done,\n    target: tick,\n  });\n\n  return tick;\n}\n\nmodule.exports = { throttle };\n","module.exports.combineEvents = require('./combine-events').combineEvents;\nmodule.exports.condition = require('./condition').condition;\nmodule.exports.debounce = require('./debounce').debounce;\nmodule.exports.debug = require('./debug').debug;\nmodule.exports.delay = require('./delay').delay;\nmodule.exports.every = require('./every').every;\nmodule.exports.inFlight = require('./in-flight').inFlight;\nmodule.exports.pending = require('./pending').pending;\nmodule.exports.reshape = require('./reshape').reshape;\nmodule.exports.some = require('./some').some;\nmodule.exports.splitMap = require('./split-map').splitMap;\nmodule.exports.spread = require('./spread').spread;\nmodule.exports.status = require('./status').status;\nmodule.exports.throttle = require('./throttle').throttle;\n"],"names":["readConfig","part","properties","target","config","filter","name","forEach","readProperties","ɔ","createStore","createEvent","guard","merge","sample","withRegion","is","require$$0","require$$1","throwError","message","Error","argument","loc","events","reset","givenTarget","unit","isArray","Array","keys","Object","defaultShape","fill","$counter","length","$results","key","$isDone","on","value","shape","payload","newShape","source","values","map","inverse","fnOrUnit","if","test","then","thenBranch","else","elseBranch","checker","createEffect","forward","timeout","sid","TypeError","domain","Number","isFinite","actualName","shortName","rejectPromise","timeoutId","tick","timerFx","handler","parameter","clearTimeout","Promise","resolve","reject","setTimeout","from","to","done","result","getType","store","effect","event","log","type","prefix","getName","watch","console","info","logEffect","fail","compositeName","fullName","units","arguments","onCreateEvent","onCreateStore","onCreateEffect","ms","validateTimeout","milliseconds","clock","fn","doneData","combine","predicate","stores","every","effects","$inFlight","fx","count","finally","inFlight","inFlights","reduce","all","current","strategies","some","list","Boolean","rawEffects","of","strategy","push","pending","state","undefined","cases","updates","filterMap","data","__","targets","targetKey","hasTargetKey","object","defaultValue","$status","require$$2","require$$3","require$$4","require$$5","require$$6","require$$7","require$$8","require$$9","require$$10","require$$11","require$$12"],"mappings":"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"}