"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t=e(require("effector"));const o=(e,t,n={})=>("object"!=typeof e||null===e||(e.config&&o(e.config,t,n),function(e,t,o){o.filter((t=>void 0!==e[t])).forEach((o=>{t[o]=e[o]}))}(e,n,t),e.ɔ&&o(e.ɔ,t,n)),n);var n={readConfig:o};const{createStore:r,createEvent:s,guard:c,merge:i,sample:a,withRegion:u,is:f}=t,{readConfig:m}=n,l=e=>{throw new Error(e)};var d=function(e){const{loc:t,name:o="unknown",events:n,reset:d,target:p}=m(e,["loc","name","events","reset","target"]),g=p||s({name:o});return f.unit(g)||l("target should be a unit"),d&&!f.unit(d)&&l("reset should be a unit"),u(g,(()=>{const e=Array.isArray(n),s=Object.keys(n),u=e?[...s].fill():{},f=r(s.length,{name:o+"Counter",loc:t}),m=r(u,{name:o+"Results",loc:t});f.reset(a(g)),m.reset(g),d&&(f.reset(a(d)),m.reset(d));for(const t of s){const o=r(!1).on(n[t],(()=>!0)).reset(g);d&&o.reset(d),f.on(o,(e=>e-1)),m.on(n[t],((o,n)=>{const r=e?[...o]:{...o};return r[t]=n,r}))}c({source:a(m,i(Object.values(n))),filter:f.map((e=>0===e)),target:g})})),g};const{is:p,guard:g,createEvent:v}=t,{readConfig:h}=n;function y(e){return p.unit(e)?e.map((e=>!e)):t=>!e(t)}var b=function(e){const{name:t="unknown",source:o=v({name:t+"Source"}),if:n,then:r,else:s}=h(e,["name","source","if","then","else"]),c=p.unit(n)||"function"==typeof n?n:e=>e===n;return r&&g({source:o,filter:c,target:r}),s&&g({source:o,filter:y(c),target:s}),o};const{is:w,createEffect:E,forward:C,createEvent:T}=t,{readConfig:x}=n;var k=function(e){const{source:t,timeout:o,target:n,sid:r,loc:s,name:c}=x(e,["source","timeout","target","loc","name","sid"]);if(!w.unit(t))throw new TypeError("source must be unit from effector");if(w.domain(t))throw new TypeError("source cannot be domain");if("number"!=typeof o||o<0||!Number.isFinite(o))throw new Error(`timeout must be positive number or zero. Received: "${o}"`);const i=c||t.shortName||"unknown";let a,u;const f=n||T({name:i+"DebounceTick",loc:s}),m=E({name:i+"DebounceTimer",sid:r,loc:s,handler:e=>(clearTimeout(u),a&&a(),new Promise(((t,n)=>{a=n,u=setTimeout(t,o,e)})))});return C({from:t,to:m}),C({from:m.done.map((({result:e})=>e)),to:f}),f};const{is:N}=t;function S(e){return N.store(e)?"store":N.effect(e)?"effect":N.event(e)?"event":N.domain(e)?"domain":N.unit(e)?"unit":"unknown"}function j(e,t,o=""){const n=o+D(e);e.watch((e=>{console.info(`[${t}] ${n}`,e)}))}function P(e){j(e.done,"effect",D(e)+"."),j(e.fail,"effect",D(e)+".")}function D(e){return e.compositeName&&e.compositeName.fullName?e.compositeName.fullName:e.shortName?e.shortName:e.name?e.name:""}var $=function(){const e=Array.from(arguments);for(const t of e){const e=S(t);t.watch&&j(t,e),"effect"===e&&P(t),"domain"===e&&(t.onCreateEvent((e=>j(e,"event"))),t.onCreateStore((e=>j(e,"store"))),t.onCreateEffect(P))}};const{createEffect:F,createEvent:M,forward:_,is:A,sample:O}=t,{readConfig:R}=n;var z=function(e){const{loc:t,name:o="unknown",sid:n,source:r,timeout:s,target:c=M({name:o+"Delayed",sid:n,loc:t})}=R(e,["loc","sid","name","source","timeout","target"]);if(!A.unit(r))throw new TypeError("source must be a unit from effector");if(!A.unit(c))throw new TypeError("target must be a unit from effector");const i=function(e){if(A.store(e)||"function"==typeof e||"number"==typeof e)return e;throw new TypeError(`'timeout' argument must be a function, Store, or a number. Passed "${typeof e}"`)}(s),a=F({config:{name:o+"DelayTimer",loc:t},handler:({payload:e,milliseconds:t})=>new Promise((o=>{setTimeout(o,t,e)}))});return O({source:{milliseconds:i},clock:r,fn:({milliseconds:e},t)=>({payload:t,milliseconds:"function"==typeof e?e(t):e}),target:a}),_({from:a.doneData,to:c}),c};const{combine:B}=t,{readConfig:V}=n;var q=function(e){const{predicate:t,stores:o}=V(e,["predicate","stores"]),n="function"==typeof t?t:e=>e===t;return B(o,(e=>e.every(n)))};const{combine:G}=t,{readConfig:H}=n;var I=function(e){const{effects:t,domain:o,sid:n,name:r,loc:s}=H(e,["effects","domain","sid","name","loc"]);if(o){const e=o.createStore(0,{sid:n,name:r,loc:s});return o.onCreateEffect((t=>{e.on(t,(e=>e+1)).on(t.finally,(e=>e-1))})),e}return G(t.map((e=>e.inFlight)),(e=>e.reduce(((e,t)=>e+t),0)))};const{combine:J,is:K}=t,{readConfig:L}=n,Q={some:e=>e.some(Boolean),every:e=>e.every(Boolean)};var U=function(e){const{effects:t,domain:o,of:n="some"}=L(e,["effects","domain","of"]);if(!K.domain(o)&&!t)throw new TypeError("domain or effects should be passed");if("some"!==n&&"every"!==n)throw new TypeError(`strategy parameter "of" can be "every" or "some". Passed: "${n}"`);let r=t;const s=Q[n];return o&&(r=[],o.onCreateEffect((e=>r.push(e)))),J(r.map((e=>e.pending)),s)};const{readConfig:W}=n;var X=function(e){const{source:t,shape:o}=W(e,["source","shape"]),n={};for(const e in o)if(e in o){const r=o[e];n[e]=t.map((e=>{const t=r(e);return void 0===t?null:t}))}return n};const{combine:Y}=t,{readConfig:Z}=n;var ee=function(e){const{predicate:t,stores:o}=Z(e,["predicate","stores"]),n="function"==typeof t?t:e=>e===t;return Y(o,(e=>e.some(n)))};const{is:te}=t,{readConfig:oe}=n;var ne=function(e){const{source:t,cases:o}=oe(e,["source","cases"]),n={};let r=te.store(t)?t.updates:t;for(const e in o)if(e in o){const t=o[e];n[e]=r.filterMap(t),r=r.filter({fn:e=>!t(e)})}return n.__=r,n};const{createEvent:re,sample:se,guard:ce}=t,{readConfig:ie}=n;var ae=function(e){const{loc:t,name:o="unknown",source:n=re({loc:t,name:o+"Source"}),targets:r}=ie(e,["loc","name","source","targets"]);for(const e in r)if(e in r){const t=ce({source:n,filter:t=>"object"==typeof t&&null!==t&&e in t});se({source:t,fn:t=>t[e],target:r[e]})}return n};const{createStore:ue}=t,{readConfig:fe}=n;var me=function(e){const{sid:t,name:o,loc:n,effect:r,defaultValue:s="initial"}=fe(e,["sid","name","loc","effect","defaultValue"]),c=ue(s,{sid:t,loc:n,name:o});return c.on(r,(()=>"pending")).on(r.done,(()=>"done")).on(r.fail,(()=>"fail")),c};const{createEffect:le,createEvent:de,guard:pe,is:ge,sample:ve}=t,{readConfig:he}=n;var ye=d,be=b,we=k,Ee=$,Ce=z,Te=q,xe=I,ke=U,Ne=X,Se=ee,je=ne,Pe=ae,De=me,$e=function(e){const{source:t,timeout:o,target:n,sid:r,loc:s,name:c}=he(e,["source","timeout","target","loc","name","sid"]);if(!ge.unit(t))throw new TypeError("source must be unit from effector");if("number"!=typeof o||o<0)throw new Error("timeout must be positive number or zero");const i=c||t.shortName||"unknown",a=n||de({name:i+"ThrottleTick",loc:s}),u=le({name:i+"ThrottleTimer",sid:r,loc:s,handler:()=>new Promise((e=>setTimeout(e,o)))});return pe({source:t,filter:u.pending.map((e=>!e)),target:u}),ve({source:t,clock:u.done,target:a}),a},Fe={combineEvents:ye,condition:be,debounce:we,debug:Ee,delay:Ce,every:Te,inFlight:xe,pending:ke,reshape:Ne,some:Se,splitMap:je,spread:Pe,status:De,throttle:$e};exports.combineEvents=ye,exports.condition=be,exports.debounce=we,exports.debug=Ee,exports.default=Fe,exports.delay=Ce,exports.every=Te,exports.inFlight=xe,exports.pending=ke,exports.reshape=Ne,exports.some=Se,exports.splitMap=je,exports.spread=Pe,exports.status=De,exports.throttle=$e;
//# sourceMappingURL=patronum.cjs.js.map
