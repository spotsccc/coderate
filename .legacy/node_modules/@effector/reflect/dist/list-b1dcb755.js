'use strict';

var react = require('react');
var effector = require('effector');

function reflectCreateFactory(context) {
  var reflect = reflectFactory(context);
  return function createReflect(view) {
    return function (bind, params) {
      return reflect(Object.assign({
        view: view,
        bind: bind
      }, params));
    };
  };
}
function reflectFactory(context) {
  return function reflect(config) {
    var events = {};
    var stores = {};
    var data = {};

    for (var key in config.bind) {
      var value = config.bind[key];

      if (effector.is.event(value) || effector.is.effect(value)) {
        events[key] = value;
      } else if (effector.is.store(value)) {
        stores[key] = value;
      } else {
        data[key] = value;
      }
    }

    var $bind = isEmpty(stores) ? null : effector.combine(stores);
    return function (props) {
      var _a, _b;

      var storeProps = $bind ? context.useStore($bind) : {};
      var eventsProps = context.useEvent(events);
      var elementProps = Object.assign({}, storeProps, eventsProps, data, props);
      var hookMounted = readHook((_a = config.hooks) === null || _a === void 0 ? void 0 : _a.mounted, context);
      var hookUnmounted = readHook((_b = config.hooks) === null || _b === void 0 ? void 0 : _b.unmounted, context);
      react.useEffect(function () {
        if (hookMounted) hookMounted();
        return function () {
          if (hookUnmounted) hookUnmounted();
        };
      }, []);
      return /*#__PURE__*/react.createElement(config.view, elementProps);
    };
  };
}

function readHook(hook, context) {
  if (hook) {
    if (effector.is.event(hook) || effector.is.effect(hook)) {
      return context.useEvent(hook);
    }

    return hook;
  }
}

function isEmpty(map) {
  return Object.keys(map).length === 0;
}

var Default = function Default() {
  return null;
};

function variantFactory(context) {
  var reflect = reflectFactory(context);
  return function variant(config) {
    var _a;

    function View(props) {
      var _a, _b;

      var nameOfCase = context.useStore(config.source);
      var Component = (_b = (_a = config.cases[nameOfCase]) !== null && _a !== void 0 ? _a : config["default"]) !== null && _b !== void 0 ? _b : Default;
      return /*#__PURE__*/react.createElement(Component, props);
    }

    var bind = (_a = config.bind) !== null && _a !== void 0 ? _a : {};
    return reflect({
      bind: bind,
      view: View,
      hooks: config.hooks
    });
  };
}

function listFactory(context) {
  var reflect = reflectFactory(context);
  return function list(config) {
    var ItemView = reflect({
      view: config.view,
      bind: config.bind,
      hooks: config.hooks
    });
    var listConfig = {
      getKey: config.getKey,
      fn: function fn(value, index) {
        var finalProps = react.useMemo(function () {
          var props = {};

          for (var prop in config.mapItem) {
            if ({}.hasOwnProperty.call(config.mapItem, prop)) {
              // for some reason TS can't properly infer `prop` type here
              var fn = config.mapItem[prop];
              var propValue = fn(value, index);
              props[prop] = propValue;
            }
          }

          return props;
        }, [value, index]);
        return /*#__PURE__*/react.createElement(ItemView, finalProps);
      }
    };
    return function () {
      return context.useList(config.source, listConfig);
    };
  };
}

exports.listFactory = listFactory;
exports.reflectCreateFactory = reflectCreateFactory;
exports.reflectFactory = reflectFactory;
exports.variantFactory = variantFactory;
